From fea9c7bbfdacf6a50556893b4a382a256a4e7539 Mon Sep 17 00:00:00 2001
From: Ji Luo <ji.luo@nxp.com>
Date: Wed, 7 Dec 2022 14:10:37 +0800
Subject: [PATCH] MA-21007 matter: add trusty os based matter support

add support to provision matter device attestation certs
(PAI, DAC, CD and DAC private key)to secure storage which
is managed by trusty os.
 provision commands:
   $ fastboot stage <path-to-PAI-CERT>
   $ fastboot oem set-matter-pai-cert
   $ fastboot stage <path-to-DAC-CERT>
   $ fastboot oem set-matter-dac-cert
   $ fastboot stage <path-to-CD-CERT>
   $ fastboot oem set-matter-cd-cert
   $ fastboot stage <path-to-DAC-PRIVATE_KEY>
   $ fastboot oem set-matter-dac-private-key

Change-Id: I6743e92d644d1d6f55e7818a7cf7a901c26223be
Signed-off-by: Ji Luo <ji.luo@nxp.com>
---
 arch/arm/mach-imx/Kconfig                     |   5 +
 arch/arm/mach-imx/spl.c                       |   2 +-
 board/freescale/imx8mm_evk/imx8mm_evk.c       |   6 +
 cmd/booti.c                                   |   8 +
 common/spl/spl_fit.c                          |   2 +-
 configs/imx8mm_evk_matter_trusty_defconfig    | 211 ++++++++++++
 disk/part_efi.c                               |   2 +-
 drivers/fastboot/fb_fsl/fb_fsl_command.c      |  93 ++++-
 include/configs/imx8mm_evk.h                  |   4 +
 include/fastboot.h                            |   2 +-
 include/fb_fsl.h                              |   7 +
 include/interface/matter/matter.h             |  62 ++++
 include/trusty/libtipc.h                      |   1 +
 include/trusty/matter.h                       |  57 ++++
 lib/trusty/ql-tipc/Makefile                   |   2 +
 lib/trusty/ql-tipc/libtipc.c                  |  23 +-
 lib/trusty/ql-tipc/matter.c                   | 318 ++++++++++++++++++
 .../ql-tipc/sysdeps/storage_ops_uboot.c       |  45 ++-
 18 files changed, 829 insertions(+), 21 deletions(-)
 create mode 100644 configs/imx8mm_evk_matter_trusty_defconfig
 create mode 100644 include/interface/matter/matter.h
 create mode 100644 include/trusty/matter.h
 create mode 100644 lib/trusty/ql-tipc/matter.c

diff --git a/arch/arm/mach-imx/Kconfig b/arch/arm/mach-imx/Kconfig
index 7bc4f2dec1..93b97951c0 100644
--- a/arch/arm/mach-imx/Kconfig
+++ b/arch/arm/mach-imx/Kconfig
@@ -388,6 +388,11 @@ config SECURE_UNLOCK
 	bool "Enable secure unlock for Android devices, it can only be enabled on HAB closed board"
 	depends on IMX_TRUSTY_OS
 
+config IMX_MATTER_TRUSTY
+	bool "Enable Trusty OS feature for Matter"
+	depends on IMX_TRUSTY_OS
+	default n
+
 endmenu
 
 config APPEND_BOOTARGS
diff --git a/arch/arm/mach-imx/spl.c b/arch/arm/mach-imx/spl.c
index a24c98df12..e6009227e2 100644
--- a/arch/arm/mach-imx/spl.c
+++ b/arch/arm/mach-imx/spl.c
@@ -516,7 +516,7 @@ void board_spl_fit_post_load(const void *fit, struct spl_image_info *spl_image)
 
 }
 
-#ifdef CONFIG_IMX_TRUSTY_OS
+#if defined(CONFIG_IMX_TRUSTY_OS) && !defined(CONFIG_IMX_MATTER_TRUSTY)
 int check_rollback_index(struct spl_image_info *spl_image, struct mmc *mmc);
 int check_rpmb_blob(struct mmc *mmc);
 
diff --git a/board/freescale/imx8mm_evk/imx8mm_evk.c b/board/freescale/imx8mm_evk/imx8mm_evk.c
index 39f6d6281c..f92e808c43 100644
--- a/board/freescale/imx8mm_evk/imx8mm_evk.c
+++ b/board/freescale/imx8mm_evk/imx8mm_evk.c
@@ -363,3 +363,9 @@ int is_recovery_key_pressing(void)
 }
 #endif /* CONFIG_ANDROID_RECOVERY */
 #endif /* CONFIG_FSL_FASTBOOT */
+
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+int board_get_emmc_id(void) {
+	return 2;
+}
+#endif
diff --git a/cmd/booti.c b/cmd/booti.c
index d820930fe8..c88676d582 100644
--- a/cmd/booti.c
+++ b/cmd/booti.c
@@ -16,6 +16,10 @@
 #include <linux/kernel.h>
 #include <linux/sizes.h>
 
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+#include <trusty/libtipc.h>
+#endif
+
 DECLARE_GLOBAL_DATA_PTR;
 /*
  * Image booting support
@@ -118,6 +122,10 @@ int do_booti(struct cmd_tbl *cmdtp, int flag, int argc, char *const argv[])
 	/* Consume 'booti' */
 	argc--; argv++;
 
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+	trusty_ipc_shutdown();
+#endif
+
 	if (booti_start(cmdtp, flag, argc, argv, &images))
 		return 1;
 
diff --git a/common/spl/spl_fit.c b/common/spl/spl_fit.c
index 9d5a6dccec..56a22ad70a 100644
--- a/common/spl/spl_fit.c
+++ b/common/spl/spl_fit.c
@@ -741,7 +741,7 @@ int spl_load_simple_fit(struct spl_image_info *spl_image,
 	if (ret < 0)
 		return ret;
 
-#ifdef CONFIG_IMX_TRUSTY_OS
+#if defined(CONFIG_IMX_TRUSTY_OS) && !defined(CONFIG_IMX_MATTER_TRUSTY)
 	int rbindex;
 	rbindex = spl_fit_get_rbindex(ctx.fit);
 	if (rbindex < 0) {
diff --git a/configs/imx8mm_evk_matter_trusty_defconfig b/configs/imx8mm_evk_matter_trusty_defconfig
new file mode 100644
index 0000000000..f43ace7afa
--- /dev/null
+++ b/configs/imx8mm_evk_matter_trusty_defconfig
@@ -0,0 +1,211 @@
+CONFIG_ARM=y
+CONFIG_ARCH_IMX8M=y
+CONFIG_SYS_TEXT_BASE=0x40200000
+CONFIG_SYS_MALLOC_LEN=0x2000000
+CONFIG_SYS_MALLOC_F_LEN=0x10000
+CONFIG_SPL_GPIO=y
+CONFIG_SPL_LIBCOMMON_SUPPORT=y
+CONFIG_SPL_LIBGENERIC_SUPPORT=y
+CONFIG_ENV_SIZE=0x4000
+CONFIG_ENV_OFFSET=0x400000
+CONFIG_SYS_MEMTEST_START=0x40000000
+CONFIG_SYS_MEMTEST_END=0x80000000
+CONFIG_SYS_I2C_MXC_I2C1=y
+CONFIG_SYS_I2C_MXC_I2C2=y
+CONFIG_SYS_I2C_MXC_I2C3=y
+CONFIG_DM_GPIO=y
+CONFIG_SPL_TEXT_BASE=0x7E1000
+CONFIG_TARGET_IMX8MM_EVK=y
+CONFIG_ARCH_MISC_INIT=y
+CONFIG_SPL_MMC=y
+CONFIG_SPL_SERIAL=y
+CONFIG_SPL_DRIVERS_MISC=y
+CONFIG_SPL=y
+CONFIG_DEFAULT_DEVICE_TREE="imx8mm-evk"
+CONFIG_CSF_SIZE=0x2000
+CONFIG_DISTRO_DEFAULTS=y
+CONFIG_BOOTCOMMAND="run sr_ir_v2_cmd;run distro_bootcmd;run bsp_bootcmd"
+CONFIG_SYS_LOAD_ADDR=0x40400000
+CONFIG_FIT=y
+CONFIG_FIT_EXTERNAL_OFFSET=0x3000
+CONFIG_SPL_LOAD_FIT=y
+# CONFIG_USE_SPL_FIT_GENERATOR is not set
+CONFIG_OF_SYSTEM_SETUP=y
+CONFIG_BOARD_LATE_INIT=y
+CONFIG_BOARD_EARLY_INIT_F=y
+CONFIG_SPL_BOARD_INIT=y
+CONFIG_SPL_SEPARATE_BSS=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_USE_SECTOR=y
+CONFIG_SYS_MMCSD_RAW_MODE_U_BOOT_SECTOR=0x300
+CONFIG_SPL_I2C=y
+CONFIG_SPL_POWER=y
+CONFIG_SPL_WATCHDOG=y
+CONFIG_NR_DRAM_BANKS=2
+CONFIG_SYS_PROMPT="u-boot=> "
+# CONFIG_CMD_EXPORTENV is not set
+# CONFIG_CMD_IMPORTENV is not set
+CONFIG_CMD_CRC32=y
+CONFIG_CRC32_VERIFY=y
+# CONFIG_BOOTM_NETBSD is not set
+CONFIG_CMD_NVEDIT_EFI=y
+CONFIG_CMD_CLK=y
+CONFIG_CMD_DFU=y
+CONFIG_CMD_FUSE=y
+CONFIG_CMD_GPIO=y
+CONFIG_CMD_GPT=y
+CONFIG_CMD_I2C=y
+CONFIG_CMD_MMC=y
+CONFIG_CMD_POWEROFF=y
+CONFIG_CMD_PART=y
+CONFIG_CMD_DHCP=y
+CONFIG_CMD_MII=y
+CONFIG_CMD_PING=y
+CONFIG_CMD_SNTP=y
+CONFIG_CMD_CACHE=y
+CONFIG_CMD_EFIDEBUG=y
+CONFIG_CMD_RTC=y
+CONFIG_CMD_TIME=y
+CONFIG_CMD_GETTIME=y
+CONFIG_CMD_TIMER=y
+CONFIG_CMD_REGULATOR=y
+CONFIG_CMD_MEMTEST=y
+CONFIG_CMD_EXT2=y
+CONFIG_CMD_EXT4=y
+CONFIG_CMD_HASH=y
+CONFIG_CMD_EXT4_WRITE=y
+CONFIG_CMD_FAT=y
+CONFIG_CMD_SF=y
+CONFIG_CMD_FS_GENERIC=y
+CONFIG_CMD_USB=y
+CONFIG_CMD_USB_MASS_STORAGE=y
+CONFIG_OF_CONTROL=y
+CONFIG_ENV_OVERWRITE=y
+CONFIG_DEFAULT_FDT_FILE="imx8mm-evk.dtb"
+CONFIG_ENV_IS_IN_MMC=y
+CONFIG_SYS_RELOC_GD_ENV_ADDR=y
+CONFIG_SYS_MMC_ENV_DEV=1
+CONFIG_ENV_VARS_UBOOT_RUNTIME_CONFIG=y
+CONFIG_NET_RANDOM_ETHADDR=y
+CONFIG_CLK_COMPOSITE_CCF=y
+CONFIG_CLK_IMX8MM=y
+CONFIG_DFU_TFTP=y
+CONFIG_DFU_MMC=y
+CONFIG_DFU_RAM=y
+CONFIG_UDP_FUNCTION_FASTBOOT=y
+CONFIG_MXC_GPIO=y
+CONFIG_FASTBOOT=y
+CONFIG_USB_FUNCTION_FASTBOOT=y
+CONFIG_CMD_FASTBOOT=y
+CONFIG_ANDROID_BOOT_IMAGE=y
+CONFIG_FASTBOOT_UUU_SUPPORT=y
+CONFIG_FASTBOOT_BUF_ADDR=0x42800000
+CONFIG_FASTBOOT_BUF_SIZE=0x40000000
+CONFIG_FASTBOOT_FLASH=y
+
+CONFIG_DM_I2C=y
+CONFIG_SPL_SYS_I2C_LEGACY=y
+CONFIG_SYS_I2C_MXC=y
+CONFIG_DM_MMC=y
+CONFIG_EFI_PARTITION=y
+CONFIG_SUPPORT_EMMC_RPMB=y
+CONFIG_SUPPORT_EMMC_BOOT=y
+CONFIG_MMC_IO_VOLTAGE=y
+CONFIG_MMC_UHS_SUPPORT=y
+CONFIG_MMC_HS400_ES_SUPPORT=y
+CONFIG_MMC_HS400_SUPPORT=y
+CONFIG_FSL_USDHC=y
+CONFIG_FSL_ESDHC_IMX=y
+CONFIG_DM_SPI_FLASH=y
+CONFIG_DM_SPI=y
+CONFIG_NXP_FSPI=y
+CONFIG_SPI=y
+CONFIG_SPI_FLASH=y
+CONFIG_SPI_FLASH_BAR=y
+CONFIG_SPI_FLASH_STMICRO=y
+CONFIG_SF_DEFAULT_BUS=0
+CONFIG_SF_DEFAULT_CS=0
+CONFIG_SF_DEFAULT_SPEED=40000000
+CONFIG_SF_DEFAULT_MODE=0
+
+CONFIG_PHYLIB=y
+CONFIG_PHY_ATHEROS=y
+CONFIG_PHY_REALTEK=y
+CONFIG_DM_ETH=y
+CONFIG_PHY_GIGE=y
+CONFIG_FEC_MXC=y
+CONFIG_MII=y
+CONFIG_PINCTRL=y
+CONFIG_PINCTRL_IMX8M=y
+CONFIG_SPL_POWER_LEGACY=y
+CONFIG_DM_REGULATOR=y
+CONFIG_DM_REGULATOR_FIXED=y
+CONFIG_DM_REGULATOR_GPIO=y
+CONFIG_SPL_POWER_I2C=y
+CONFIG_DM_RTC=y
+CONFIG_RTC_EMULATION=y
+CONFIG_MXC_UART=y
+CONFIG_SYSRESET=y
+CONFIG_SYSRESET_PSCI=y
+CONFIG_DM_THERMAL=y
+CONFIG_IMX_TMU=y
+CONFIG_USB_TCPC=y
+CONFIG_USB=y
+CONFIG_USB_GADGET=y
+CONFIG_USB_STORAGE=y
+CONFIG_DM_USB=y
+CONFIG_CI_UDC=y
+CONFIG_USB_EHCI_HCD=y
+CONFIG_USB_HOST_ETHER=y
+CONFIG_USB_ETHER_ASIX=y
+CONFIG_USB_ETHER_RTL8152=y
+
+CONFIG_USB_GADGET_MANUFACTURER="FSL"
+CONFIG_USB_GADGET_VENDOR_NUM=0x1fc9
+CONFIG_USB_GADGET_PRODUCT_NUM=0x0152
+
+CONFIG_SPL_USB_HOST=y
+CONFIG_SPL_USB_GADGET=y
+CONFIG_SPL_USB_SDP_SUPPORT=y
+CONFIG_SDP_LOADADDR=0x40400000
+
+CONFIG_OF_LIBFDT_OVERLAY=y
+
+CONFIG_REGMAP=y
+CONFIG_SYSCON=y
+CONFIG_DM_RESET=y
+CONFIG_RESET_DISPMIX=y
+CONFIG_VIDEO_IMX_SEC_DSI=y
+CONFIG_DM_VIDEO=y
+CONFIG_BMP_16BPP=y
+CONFIG_BMP_24BPP=y
+CONFIG_BMP_32BPP=y
+CONFIG_VIDEO_MXS=y
+CONFIG_VIDEO_LOGO=y
+CONFIG_VIDEO_LCD_RAYDIUM_RM67191=y
+CONFIG_VIDEO_ADV7535=y
+CONFIG_SYS_WHITE_ON_BLACK=y
+CONFIG_SPLASH_SCREEN=y
+CONFIG_SPLASH_SCREEN_ALIGN=y
+CONFIG_CMD_BMP=y
+
+CONFIG_LEGACY_IMAGE_FORMAT=y
+CONFIG_LZO=y
+CONFIG_BZIP2=y
+CONFIG_EFI_SET_TIME=y
+CONFIG_EFI_RUNTIME_UPDATE_CAPSULE=y
+CONFIG_EFI_CAPSULE_ON_DISK=y
+CONFIG_EFI_CAPSULE_FIRMWARE_RAW=y
+CONFIG_EFI_SECURE_BOOT=y
+CONFIG_SPL_RSA=y
+CONFIG_SHA384=y
+CONFIG_EFI_VAR_BUF_SIZE=139264
+CONFIG_EFI_IGNORE_OSINDICATIONS=y
+CONFIG_EFI_CAPSULE_AUTHENTICATE=y
+CONFIG_EFI_MM_COMM_TEE=y
+CONFIG_EFI_ESRT=y
+CONFIG_EFI_HAVE_CAPSULE_UPDATE=y
+CONFIG_FIT_SIGNATURE=y
+CONFIG_IMX_TRUSTY_OS=y
+CONFIG_IMX_MATTER_TRUSTY=y
+CONFIG_LZ4=y
+CONFIG_SPL_LZ4=y
diff --git a/disk/part_efi.c b/disk/part_efi.c
index e1d9dced03..dda0510798 100644
--- a/disk/part_efi.c
+++ b/disk/part_efi.c
@@ -1196,7 +1196,7 @@ static gpt_entry *alloc_read_gpt_entries(struct blk_desc *dev_desc,
 	 * don't forget to free the memory after use.
 	 */
 	if (count != 0) {
-#if (defined(CONFIG_DUAL_BOOTLOADER) || defined(CONFIG_IMX_TRUSTY_OS)) && defined(CONFIG_SPL_BUILD)
+#if (defined(CONFIG_DUAL_BOOTLOADER) || defined(CONFIG_IMX_TRUSTY_OS)) && defined(CONFIG_SPL_BUILD) && !defined(CONFIG_IMX_MATTER_TRUSTY)
 		pte = (gpt_entry *)CONFIG_SYS_SPL_PTE_RAM_BASE;
 #else
 		pte = memalign(ARCH_DMA_MINALIGN,
diff --git a/drivers/fastboot/fb_fsl/fb_fsl_command.c b/drivers/fastboot/fb_fsl/fb_fsl_command.c
index 61b1a9d580..741c6cb018 100644
--- a/drivers/fastboot/fb_fsl/fb_fsl_command.c
+++ b/drivers/fastboot/fb_fsl/fb_fsl_command.c
@@ -338,6 +338,20 @@ void fastboot_data_complete(char *response)
 	fastboot_bytes_expected = 0;
 }
 
+static bool endswith(char* s, char* subs) {
+	if (!s || !subs)
+		return false;
+	uint32_t len = strlen(s);
+	uint32_t sublen = strlen(subs);
+	if (len < sublen) {
+		return false;
+	}
+	if (strncmp(s + len - sublen, subs, sublen)) {
+		return false;
+	}
+	return true;
+}
+
 #if defined(CONFIG_FASTBOOT_LOCK)
 static int partition_table_valid(void)
 {
@@ -458,20 +472,6 @@ static FbLockState do_fastboot_lock(void)
 	return FASTBOOT_LOCK;
 }
 
-static bool endswith(char* s, char* subs) {
-	if (!s || !subs)
-		return false;
-	uint32_t len = strlen(s);
-	uint32_t sublen = strlen(subs);
-	if (len < sublen) {
-		return false;
-	}
-	if (strncmp(s + len - sublen, subs, sublen)) {
-		return false;
-	}
-	return true;
-}
-
 static bool erase_uboot_env(void) {
 	FbLockState status;
 	status = fastboot_get_lock_stat();
@@ -798,6 +798,69 @@ static void flashing(char *cmd, char *response)
 }
 #endif /* CONFIG_FASTBOOT_LOCK */
 
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+static void flashing(char *cmd, char *response)
+{
+	if (endswith(cmd, SET_MATTER_DAC_CERT)) {
+		if (trusty_set_dac_cert(fastboot_buf_addr, fastboot_bytes_received)) {
+			printf("ERROR set matter dac cert failed!\n");
+			strcpy(response, "FAILInternal error!");
+		} else {
+			printf("Set matter dac cert successfully!\n");
+			strcpy(response, "OKAY");
+		}
+	} else if (endswith(cmd, SET_MATTER_PAI_CERT)) {
+		if (trusty_set_pai_cert(fastboot_buf_addr, fastboot_bytes_received)) {
+			printf("ERROR set matter pai cert failed!\n");
+			strcpy(response, "FAILInternal error!");
+		} else {
+			printf("Set matter pai cert successfully!\n");
+			strcpy(response, "OKAY");
+		}
+	} else if (endswith(cmd, SET_MATTER_CD_CERT)) {
+		if (trusty_set_cd_cert(fastboot_buf_addr, fastboot_bytes_received)) {
+			printf("ERROR set matter cd cert failed!\n");
+			strcpy(response, "FAILInternal error!");
+		} else {
+			printf("Set matter cd cert successfully!\n");
+			strcpy(response, "OKAY");
+		}
+	} else if (endswith(cmd, SET_MATTER_DAC_PRIKEY)) {
+		if (trusty_set_dac_prikey(fastboot_buf_addr, fastboot_bytes_received)) {
+			printf("ERROR set matter dac private key failed!\n");
+			strcpy(response, "FAILInternal error!");
+		} else {
+			printf("Set matter dac private key successfully!\n");
+			strcpy(response, "OKAY");
+		}
+	} else if (endswith(cmd, FASTBOOT_SET_RPMB_HARDWARE_KEY)) {
+		if (storage_set_rpmb_key()) {
+			printf("ERROR set rpmb hardware key failed!\n");
+			strcpy(response, "FAILset rpmb hardware key failed!");
+		} else
+			strcpy(response, "OKAY");
+	} else if (endswith(cmd, FASTBOOT_ERASE_RPMB)) {
+		if (storage_erase_rpmb()) {
+			printf("ERROR erase rpmb storage failed!\n");
+			strcpy(response, "FAILerase rpmb storage failed!");
+		} else {
+			printf("erase rpmb storage succeed!\n");
+			strcpy(response, "OKAY");
+		}
+	} else {
+		printf("Unknown oem command:%s\n", cmd);
+		strcpy(response, "FAILcommand not defined");
+	}
+
+	fastboot_tx_write_more(response);
+
+	/* Must call fastboot_none_resp before returning from the dispatch function
+	 *  which uses fastboot_tx_write_more
+	 */
+	fastboot_none_resp(response);
+}
+#endif
+
 #ifdef CONFIG_AVB_SUPPORT
 static void set_active_avb(char *cmd, char *response)
 {
@@ -1067,6 +1130,8 @@ static const struct {
 			.command = "flashing",
 			.dispatch = flashing,
 		},
+#endif
+#if defined(CONFIG_FASTBOOT_LOCK) || defined(CONFIG_IMX_MATTER_TRUSTY)
 		[FASTBOOT_COMMAND_OEM] = {
 			.command = "oem",
 			.dispatch = flashing,
diff --git a/include/configs/imx8mm_evk.h b/include/configs/imx8mm_evk.h
index 754a6b1a16..2ceb588d05 100644
--- a/include/configs/imx8mm_evk.h
+++ b/include/configs/imx8mm_evk.h
@@ -267,4 +267,8 @@
 #include "imx8mm_evk_android.h"
 #endif
 
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+#define NS_ARCH_ARM64 1
+#endif
+
 #endif
diff --git a/include/fastboot.h b/include/fastboot.h
index 70d5b33062..0a0e7c32db 100644
--- a/include/fastboot.h
+++ b/include/fastboot.h
@@ -51,7 +51,7 @@ enum {
 #ifdef CONFIG_FSL_FASTBOOT
 	FASTBOOT_COMMAND_UPLOAD,
 	FASTBOOT_COMMAND_GETSTAGED,
-#ifdef CONFIG_FASTBOOT_LOCK
+#if defined(CONFIG_FASTBOOT_LOCK) || defined(CONFIG_IMX_MATTER_TRUSTY)
 	FASTBOOT_COMMAND_FLASHING,
 	FASTBOOT_COMMAND_OEM,
 #endif
diff --git a/include/fb_fsl.h b/include/fb_fsl.h
index 080ea0e44b..70c0cfc75e 100644
--- a/include/fb_fsl.h
+++ b/include/fb_fsl.h
@@ -121,6 +121,13 @@
 #endif /* CONFIG_AVB_ATX */
 #endif /* CONFIG_ANDROID_THINGS_SUPPORT */
 
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+#define SET_MATTER_DAC_CERT "set-matter-dac-cert"
+#define SET_MATTER_PAI_CERT "set-matter-pai-cert"
+#define SET_MATTER_CD_CERT  "set-matter-cd-cert"
+#define SET_MATTER_DAC_PRIKEY  "set-matter-dac-private-key"
+#endif
+
 #ifndef TEE_HWPARTITION_ID
 #define TEE_HWPARTITION_ID 2
 #endif
diff --git a/include/interface/matter/matter.h b/include/interface/matter/matter.h
new file mode 100644
index 0000000000..49fed035e4
--- /dev/null
+++ b/include/interface/matter/matter.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright 2023 NXP
+ */
+
+#ifndef TRUSTY_INTERFACE_MATTER_H_
+#define TRUSTY_INTERFACE_MATTER_H_
+
+#include <trusty/sysdeps.h>
+
+#define MATTER_PORT "com.android.trusty.matter"
+#define MATTER_MAX_BUFFER_LENGTH 4096
+
+enum matter_command {
+    MATTER_RESP_BIT              = 1,
+    MATTER_STOP_BIT              = 2,
+    MATTER_REQ_SHIFT             = 2,
+
+    // bootloader commands
+    MATTER_IMPORT_DAC            = (0x1 << MATTER_REQ_SHIFT),
+    MATTER_IMPORT_PAI            = (0x2 << MATTER_REQ_SHIFT),
+    MATTER_IMPORT_CD             = (0x3 << MATTER_REQ_SHIFT),
+    MATTER_IMPORT_DAC_PRIKEY     = (0x4 << MATTER_REQ_SHIFT),
+};
+
+typedef enum {
+    MATTER_ERROR_OK = 0,
+    MATTER_ERROR_UNKNOWN_ERROR = -1,
+} matter_error_t;
+
+/**
+ * matter_message - Serial header for communicating with Matter server
+ *
+ * @cmd: the command, one of matter_command.
+ * @payload: start of the serialized command specific payload
+ */
+struct matter_message {
+    uint32_t cmd;
+    uint8_t payload[0];
+};
+
+/**
+ * matter_no_response -  Generic matter response for commands with no special
+ * response data
+ *
+ * @error: error code from command
+ */
+struct matter_no_response {
+    int32_t error;
+};
+
+/**
+ * matter_cert_data
+ *
+ * @data_size: size of |data|
+ * @data: certificate data
+ */
+struct matter_cert_data {
+    uint32_t data_size;
+    const uint8_t *data;
+} TRUSTY_ATTR_PACKED;
+
+#endif /* TRUSTY_INTERFACE_MATTER_H_ */
diff --git a/include/trusty/libtipc.h b/include/trusty/libtipc.h
index f06e9e9a0e..c7deb6c6a9 100644
--- a/include/trusty/libtipc.h
+++ b/include/trusty/libtipc.h
@@ -29,6 +29,7 @@
 #include <trusty/sysdeps.h>
 #include <trusty/hwcrypto.h>
 #include <trusty/imx_snvs.h>
+#include <trusty/matter.h>
 
 /*
  * Initialize TIPC library
diff --git a/include/trusty/matter.h b/include/trusty/matter.h
new file mode 100644
index 0000000000..027002e5e4
--- /dev/null
+++ b/include/trusty/matter.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright 2022 NXP
+ */
+
+#ifndef TRUSTY_MATTER_H_
+#define TRUSTY_MATTER_H_
+
+#include <trusty/sysdeps.h>
+#include <trusty/trusty_ipc.h>
+#include <interface/matter/matter.h>
+
+/*
+ * Initialize Matter TIPC client. Returns one of trusty_err.
+ *
+ * @dev: initialized with trusty_ipc_dev_create
+ */
+int matter_tipc_init(struct trusty_ipc_dev *dev);
+
+/*
+ * Shutdown Matter TIPC client.
+ *
+ * @dev: initialized with trusty_ipc_dev_create
+ */
+void matter_tipc_shutdown(struct trusty_ipc_dev *dev);
+
+/*
+ * set matter DAC (Device Attestation Certificate).
+ *
+ * @ cert: pointer to certificate data
+ * @ cert_size: certificate size
+ */
+int trusty_set_dac_cert(const uint8_t *cert, uint32_t cert_size);
+
+/*
+ * set matter PAI (Product Attestation Intermediate) Certificate.
+ *
+ * @ cert: pointer to certificate data
+ * @ cert_size: certificate size
+ */
+int trusty_set_pai_cert(const uint8_t *cert, uint32_t cert_size);
+
+/*
+ * set matter CD (Certification Declaration).
+ *
+ * @ cert: pointer to certificate data
+ * @ cert_size: certificate size
+ */
+int trusty_set_cd_cert(const uint8_t *cert, uint32_t cert_size);
+
+/*
+ * set matter DAC private key.
+ *
+ * @ key: pointer to DAC private key
+ * @ key_size: key size
+ */
+int trusty_set_dac_prikey(const uint8_t *key, uint32_t key_size);
+#endif /* TRUSTY_MATTER_H_ */
diff --git a/lib/trusty/ql-tipc/Makefile b/lib/trusty/ql-tipc/Makefile
index 57b48223e2..c83fc4e9d2 100644
--- a/lib/trusty/ql-tipc/Makefile
+++ b/lib/trusty/ql-tipc/Makefile
@@ -45,6 +45,8 @@ obj-y += \
     sysdeps/sysdeps_uboot.o \
     sysdeps/storage_ops_uboot.o
 
+obj-$(CONFIG_IMX_MATTER_TRUSTY) += $(QL_TIPC)/matter.o
+
 obj-$(CONFIG_ARM) += \
     $(QL_TIPC)/arch/arm/trusty_mem.o \
     $(QL_TIPC)/arch/arm/trusty_dev.o
diff --git a/lib/trusty/ql-tipc/libtipc.c b/lib/trusty/ql-tipc/libtipc.c
index d21b364c73..7a07a8034e 100644
--- a/lib/trusty/ql-tipc/libtipc.c
+++ b/lib/trusty/ql-tipc/libtipc.c
@@ -34,6 +34,7 @@
 #include <hang.h>
 #include <env.h>
 #include <trusty/imx_snvs.h>
+#include <trusty/matter.h>
 
 #define LOCAL_LOG 0
 
@@ -53,17 +54,25 @@ void trusty_ipc_shutdown(void)
      * Trusty OS is not well initialized when the rpmb
      * key is not set, skip ipc shut down to avoid panic.
      */
+#ifndef CONFIG_IMX_MATTER_TRUSTY
     if (!rpmbkey_is_set()) {
         return;
     }
+#endif
 
     (void)rpmb_storage_proxy_shutdown(_ipc_dev);
     (void)rpmb_storage_put_ctx(rpmb_ctx);
 
+#ifndef CONFIG_IMX_MATTER_TRUSTY
     (void)avb_tipc_shutdown(_ipc_dev);
     (void)km_tipc_shutdown(_ipc_dev);
+#endif
 
-#ifndef CONFIG_AVB_ATX
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+    (void)matter_tipc_shutdown(_ipc_dev);
+#endif
+
+#if !defined(CONFIG_AVB_ATX) && !defined(CONFIG_IMX_MATTER_TRUSTY)
     (void)hwcrypto_tipc_shutdown(_ipc_dev);
 #endif
 
@@ -102,7 +111,7 @@ int trusty_ipc_init(void)
     rc = rpmb_storage_proxy_init(_ipc_dev, rpmb_ctx);
     if (rc != 0) {
         trusty_error("Initlializing RPMB storage proxy service failed (%d)\n", rc);
-#ifndef CONFIG_AVB_ATX
+#if !defined(CONFIG_AVB_ATX) && !defined(CONFIG_IMX_MATTER_TRUSTY)
         /* check if rpmb key has been fused. */
         if(rpmbkey_is_set()) {
             /* Go to hang if the key has been destroyed. */
@@ -119,6 +128,7 @@ int trusty_ipc_init(void)
      * failed (when the rpmb key not set). Init the avb and keymaster service
      * only when the rpmb key has been set.
      */
+#ifndef CONFIG_IMX_MATTER_TRUSTY
     if (rpmbkey_is_set()) {
         rc = avb_tipc_init(_ipc_dev);
         if (rc != 0) {
@@ -152,6 +162,15 @@ int trusty_ipc_init(void)
         return rc;
     }
 #endif
+#endif /* CONFIG_IMX_MATTER_TRUSTY */
+
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+    rc = matter_tipc_init(_ipc_dev);
+    if (rc != 0) {
+        trusty_error("Initlializing Trusty Matter failed (%d)\n", rc);
+        return rc;
+    }
+#endif
 
     /* secure storage service init ok, use trusty backed keystore */
     if (use_keystore)
diff --git a/lib/trusty/ql-tipc/matter.c b/lib/trusty/ql-tipc/matter.c
new file mode 100644
index 0000000000..d6783f9405
--- /dev/null
+++ b/lib/trusty/ql-tipc/matter.c
@@ -0,0 +1,318 @@
+/*
+ * Copyright 2022 NXP
+ */
+
+#include <trusty/matter.h>
+#include <trusty/trusty_ipc.h>
+#include <trusty/util.h>
+
+static struct trusty_ipc_chan matter_chan;
+static bool initialized = false;
+
+#ifndef MIN
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+#endif
+
+#ifndef NELEMS
+#define NELEMS(x) (sizeof(x) / sizeof((x)[0]))
+#endif
+
+static int matter_send_request(uint32_t cmd, const void *req, size_t req_len)
+{
+    struct matter_message header = { .cmd = cmd };
+    int num_iovecs = req ? 2 : 1;
+
+    struct trusty_ipc_iovec req_iovs[2] = {
+        { .base = &header, .len = sizeof(header) },
+        { .base = (void*)req, .len = req_len },
+    };
+
+    return trusty_ipc_send(&matter_chan, req_iovs, num_iovecs, true);
+}
+
+/* Checks that the command opcode in |header| matches |expected_cmd|. Checks
+ * that |tipc_result| is a valid response size. Returns negative on error.
+ */
+static int check_response_error(uint32_t expected_cmd,
+                                struct matter_message header,
+                                int32_t tipc_result)
+{
+    if (tipc_result < 0) {
+        trusty_error("failed (%d) to recv response\n", tipc_result);
+        return tipc_result;
+    }
+    if ((size_t) tipc_result < sizeof(struct matter_message)) {
+        trusty_error("invalid response size (%d)\n", tipc_result);
+        return TRUSTY_ERR_GENERIC;
+    }
+    if ((header.cmd & ~(MATTER_STOP_BIT)) !=
+        (expected_cmd | MATTER_RESP_BIT)) {
+        trusty_error("malformed response\n");
+        return TRUSTY_ERR_GENERIC;
+    }
+    return tipc_result;
+}
+
+/* Reads the raw response to |resp| up to a maximum size of |resp_len|. Format
+ * of each message frame read from the secure side:
+ *
+ * command header : 4 bytes
+ * opaque bytes   : MAX(MATTER_MAX_BUFFER_LENGTH, x) bytes
+ *
+ * The individual message frames from the secure side are reassembled
+ * into |resp|, stripping each frame's command header. Returns the number
+ * of bytes written to |resp| on success, negative on error.
+ */
+static int matter_read_raw_response(uint32_t cmd, void *resp, size_t resp_len)
+{
+    struct matter_message header = { .cmd = cmd };
+    int rc = TRUSTY_ERR_GENERIC;
+    size_t max_resp_len = resp_len;
+    struct trusty_ipc_iovec resp_iovs[2] = {
+        { .base = &header, .len = sizeof(header) },
+        { .base = resp, .len = MIN(MATTER_MAX_BUFFER_LENGTH, max_resp_len) }
+    };
+
+    if (!resp) {
+        return TRUSTY_ERR_GENERIC;
+    }
+    resp_len = 0;
+    while (true) {
+        resp_iovs[1].base = (uint8_t*)resp + resp_len;
+        resp_iovs[1].len = MIN(MATTER_MAX_BUFFER_LENGTH,
+                               (int)max_resp_len - (int)resp_len);
+
+        rc = trusty_ipc_recv(&matter_chan, resp_iovs, NELEMS(resp_iovs), true);
+        rc = check_response_error(cmd, header, rc);
+        if (rc < 0) {
+            return rc;
+        }
+        resp_len += ((size_t)rc - sizeof(struct matter_message));
+        if (header.cmd & MATTER_STOP_BIT || resp_len >= max_resp_len) {
+            break;
+        }
+    }
+
+    return resp_len;
+}
+
+/* Reads a Matter Response message with a sized buffer. The format
+ * of the response is as follows:
+ *
+ * command header : 4 bytes
+ * error          : 4 bytes
+ * data length    : 4 bytes
+ * data           : |data length| bytes
+ *
+ * On success, |error|, |resp_data|, and |resp_data_len| are filled
+ * successfully. Returns a trusty_err.
+ */
+static int matter_read_data_response(uint32_t cmd, int32_t *error,
+                                 uint8_t* resp_data, uint32_t* resp_data_len)
+{
+    struct matter_message header = { .cmd = cmd };
+    int rc = TRUSTY_ERR_GENERIC;
+    size_t max_resp_len = *resp_data_len;
+    uint32_t resp_data_bytes = 0;
+    /* On the first read, recv the matter_message header, error code,
+     * response data length, and response data. On subsequent iterations,
+     * only recv the matter_message header and response data.
+     */
+    struct trusty_ipc_iovec resp_iovs[4] = {
+        { .base = &header, .len = sizeof(header) },
+        { .base = error, .len = sizeof(int32_t) },
+        { .base = resp_data_len, .len = sizeof(uint32_t) },
+        { .base = resp_data, .len = MIN(MATTER_MAX_BUFFER_LENGTH, max_resp_len) }
+    };
+
+    rc = trusty_ipc_recv(&matter_chan, resp_iovs, NELEMS(resp_iovs), true);
+    rc = check_response_error(cmd, header, rc);
+    if (rc < 0) {
+        return rc;
+    }
+    /* resp_data_bytes does not include the error or response data length */
+    resp_data_bytes += ((size_t)rc - sizeof(struct matter_message) -
+                        2 * sizeof(uint32_t));
+    if (header.cmd & MATTER_STOP_BIT) {
+        return TRUSTY_ERR_NONE;
+    }
+
+    /* Read the remaining response data */
+    uint8_t* resp_data_start = resp_data + resp_data_bytes;
+    size_t resp_data_remaining = *resp_data_len - resp_data_bytes;
+    rc = matter_read_raw_response(cmd, resp_data_start, resp_data_remaining);
+    if (rc < 0) {
+        return rc;
+    }
+    resp_data_bytes += rc;
+    if (*resp_data_len != resp_data_bytes) {
+        return TRUSTY_ERR_GENERIC;
+    }
+    return TRUSTY_ERR_NONE;
+}
+
+/**
+ * Convenience method to send a request to the secure side, handle rpmb
+ * operations, and receive the response. If |resp_data| is not NULL, the
+ * caller expects an additional data buffer to be returned from the secure
+ * side.
+ */
+static int matter_do_tipc(uint32_t cmd, void* req, uint32_t req_len,
+                      void* resp_data, uint32_t* resp_data_len)
+{
+    int rc = TRUSTY_ERR_GENERIC;
+    struct matter_no_response resp_header;
+
+    rc = matter_send_request(cmd, req, req_len);
+    if (rc < 0) {
+        trusty_error("%s: failed (%d) to send matter request\n", __func__, rc);
+        return rc;
+    }
+
+    if (!resp_data) {
+        rc = matter_read_raw_response(cmd, &resp_header, sizeof(resp_header));
+    } else {
+        rc = matter_read_data_response(cmd, &resp_header.error, resp_data,
+                                   resp_data_len);
+    }
+
+    if (rc < 0) {
+        trusty_error("%s: failed (%d) to read matter response\n", __func__, rc);
+        return rc;
+    }
+    if (resp_header.error != MATTER_ERROR_OK) {
+        trusty_error("%s: matter returned error (%d)\n", __func__,
+                     resp_header.error);
+        return TRUSTY_ERR_GENERIC;
+    }
+    return TRUSTY_ERR_NONE;
+}
+
+int matter_tipc_init(struct trusty_ipc_dev *dev)
+{
+    int rc = TRUSTY_ERR_GENERIC;
+
+    trusty_assert(dev);
+
+    trusty_ipc_chan_init(&matter_chan, dev);
+    trusty_debug("Connecting to Matter service\n");
+
+    /* connect to matter service and wait for connect to complete */
+    rc = trusty_ipc_connect(&matter_chan, MATTER_PORT, true);
+    if (rc < 0) {
+        trusty_error("failed (%d) to connect to '%s'\n", rc, MATTER_PORT);
+        return rc;
+    }
+
+    /* mark as initialized */
+    initialized = true;
+
+    return TRUSTY_ERR_NONE;
+}
+
+void matter_tipc_shutdown(struct trusty_ipc_dev *dev)
+{
+    if (!initialized)
+        return;
+    /* close channel */
+    trusty_ipc_close(&matter_chan);
+
+    initialized = false;
+}
+
+static uint8_t *append_to_buf(uint8_t *buf, const void *data, size_t data_len)
+{
+    if (data && data_len) {
+        trusty_memcpy(buf, data, data_len);
+    }
+    return buf + data_len;
+}
+
+static uint8_t *append_uint32_to_buf(uint8_t *buf, uint32_t val)
+{
+    return append_to_buf(buf, &val, sizeof(val));
+}
+
+static uint8_t *append_sized_buf_to_buf(uint8_t *buf, const uint8_t *data,
+                                 uint32_t data_len)
+{
+    buf = append_uint32_to_buf(buf, data_len);
+    return append_to_buf(buf, data, data_len);
+}
+
+static int matter_cert_data_serialize(const struct matter_cert_data *data, uint8_t** out, uint32_t *out_size)
+{
+    uint8_t *tmp;
+
+    if (!out || !data || !out_size) {
+        return TRUSTY_ERR_INVALID_ARGS;
+    }
+    *out_size = (sizeof(data->data_size) + data->data_size);
+    *out = trusty_calloc(*out_size, 1);
+    if (!*out) {
+        return TRUSTY_ERR_NO_MEMORY;
+    }
+
+    tmp = append_sized_buf_to_buf(*out, data->data, data->data_size);
+
+    return TRUSTY_ERR_NONE;
+}
+
+static int trusty_send_cert_data(uint32_t cmd, const uint8_t *data, uint32_t data_size)
+{
+    struct matter_cert_data cert_data = {
+        .data_size = data_size,
+        .data = data,
+    };
+    uint8_t *req = NULL;
+    uint32_t req_size = 0;
+    int rc = matter_cert_data_serialize(&cert_data, &req, &req_size);
+
+    if (rc < 0) {
+        trusty_error("failed (%d) to serialize request\n", rc);
+        goto end;
+    }
+    rc = matter_do_tipc(cmd, req, req_size, NULL, NULL);
+
+end:
+    if (req) {
+        trusty_free(req);
+    }
+    return rc;
+}
+
+int trusty_set_dac_cert(const uint8_t *cert, uint32_t cert_size)
+{
+    if (!initialized) {
+        trusty_error("Matter TIPC client not initialized!\n");
+        return -1;
+    }
+    return trusty_send_cert_data(MATTER_IMPORT_DAC, cert, cert_size);
+}
+
+int trusty_set_pai_cert(const uint8_t *cert, uint32_t cert_size)
+{
+    if (!initialized) {
+        trusty_error("Matter TIPC client not initialized!\n");
+        return -1;
+    }
+    return trusty_send_cert_data(MATTER_IMPORT_PAI, cert, cert_size);
+}
+
+int trusty_set_cd_cert(const uint8_t *cert, uint32_t cert_size)
+{
+    if (!initialized) {
+        trusty_error("Matter TIPC client not initialized!\n");
+        return -1;
+    }
+    return trusty_send_cert_data(MATTER_IMPORT_CD, cert, cert_size);
+}
+
+int trusty_set_dac_prikey(const uint8_t *key, uint32_t key_size)
+{
+    if (!initialized) {
+        trusty_error("Matter TIPC client not initialized!\n");
+        return -1;
+    }
+    return trusty_send_cert_data(MATTER_IMPORT_DAC_PRIKEY, key, key_size);
+}
diff --git a/lib/trusty/ql-tipc/sysdeps/storage_ops_uboot.c b/lib/trusty/ql-tipc/sysdeps/storage_ops_uboot.c
index cf15bf77b0..70ee3de67e 100644
--- a/lib/trusty/ql-tipc/sysdeps/storage_ops_uboot.c
+++ b/lib/trusty/ql-tipc/sysdeps/storage_ops_uboot.c
@@ -40,6 +40,10 @@ void rpmb_storage_put_ctx(void *dev)
 {
 }
 
+__weak int board_get_emmc_id(void) {
+    return mmc_get_env_dev();
+}
+
 int rpmb_storage_send(void *rpmb_dev, const void *rel_write_data,
                       size_t rel_write_size, const void *write_data,
                       size_t write_size, void *read_buf, size_t read_size)
@@ -48,11 +52,39 @@ int rpmb_storage_send(void *rpmb_dev, const void *rel_write_data,
     ALLOC_CACHE_ALIGN_BUFFER(uint8_t, rpmb_write_data, write_size);
     ALLOC_CACHE_ALIGN_BUFFER(uint8_t, rpmb_read_data, read_size);
     int ret = TRUSTY_ERR_NONE;
-    struct mmc *mmc = find_mmc_device(mmc_get_env_dev());
+
+    struct mmc *mmc = find_mmc_device(board_get_emmc_id());
     if (!mmc) {
 	trusty_error("failed to get mmc device.\n");
 	return -1;
     }
+
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+    int current_dev = mmc_get_env_dev();
+    int emmc_dev = board_get_emmc_id();
+    bool sd_boot = false;
+
+    if (emmc_dev != current_dev) {
+        /* not eMMC boot, need to switch to eMMC device */
+        if (!(mmc->has_init) && mmc_init(mmc)) {
+            trusty_error("failed to init eMMC device.\n");
+            return -1;
+        }
+
+#ifdef CONFIG_BLOCK_CACHE
+        struct blk_desc *bd = mmc_get_blk_desc(mmc);
+        blkcache_invalidate(bd->if_type, bd->devnum);
+#endif
+        /* swicth to eMMC device */
+        if (blk_select_hwpart_devnum(IF_TYPE_MMC, emmc_dev, 0)) {
+            trusty_error("failed to switch to eMMC device.\n");
+            return -1;
+        }
+
+        sd_boot = true;
+    }
+#endif
+
     struct blk_desc *desc = mmc_get_blk_desc(mmc);
     if (!desc) {
 	trusty_error("failed to get mmc desc.\n");
@@ -127,5 +159,16 @@ end:
         }
        desc->hwpart = original_part;
     }
+
+#ifdef CONFIG_IMX_MATTER_TRUSTY
+    if (sd_boot) {
+        /* swicth back to SD */
+        if (blk_select_hwpart_devnum(IF_TYPE_MMC, current_dev, 0)) {
+            trusty_error("failed to switch to SD.\n");
+            return -1;
+        }
+    }
+#endif
+
     return ret;
 }
-- 
2.36.0

