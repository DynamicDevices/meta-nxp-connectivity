From cb3d154b2855818f8f1ce04cc31e7bdbf24d56e3 Mon Sep 17 00:00:00 2001
From: nxf87843 <jean-yves.salaun@nxp.com>
Date: Thu, 15 Dec 2022 14:48:14 +0100
Subject: [PATCH] OT: commit options and patches for IW612

Signed-off-by: nxf87843 <jean-yves.salaun@nxp.com>
---
 .../files/0001-coex-buff-issue-fix.patch      |  13 +
 .../files/0002-csl-debug_prints.patch         |  45 ++
 .../files/0003-set-vsc-ir-eui64.patch         | 245 ++++++++++
 .../files/0004-set-vsc-txpwr-limit.patch      | 130 ++++++
 .../files/0005-host-spi-clear-tx-buffer.patch |  19 +
 .../0006-ot-daemon-release-resources.patch    |  43 ++
 .../files/0008-add-mfg-cmd-for-pfw.patch      | 420 ++++++++++++++++++
 .../files/0010-tcp-connection-war.patch       |  40 ++
 .../files/0011-get-vsc-txpwr-limit.patch      | 142 ++++++
 recipes-openthread/openthread/openthread.bb   |  68 ++-
 10 files changed, 1163 insertions(+), 2 deletions(-)
 create mode 100644 recipes-openthread/openthread/files/0001-coex-buff-issue-fix.patch
 create mode 100644 recipes-openthread/openthread/files/0002-csl-debug_prints.patch
 create mode 100644 recipes-openthread/openthread/files/0003-set-vsc-ir-eui64.patch
 create mode 100644 recipes-openthread/openthread/files/0004-set-vsc-txpwr-limit.patch
 create mode 100644 recipes-openthread/openthread/files/0005-host-spi-clear-tx-buffer.patch
 create mode 100644 recipes-openthread/openthread/files/0006-ot-daemon-release-resources.patch
 create mode 100644 recipes-openthread/openthread/files/0008-add-mfg-cmd-for-pfw.patch
 create mode 100644 recipes-openthread/openthread/files/0010-tcp-connection-war.patch
 create mode 100644 recipes-openthread/openthread/files/0011-get-vsc-txpwr-limit.patch

diff --git a/recipes-openthread/openthread/files/0001-coex-buff-issue-fix.patch b/recipes-openthread/openthread/files/0001-coex-buff-issue-fix.patch
new file mode 100644
index 0000000..f54e56d
--- /dev/null
+++ b/recipes-openthread/openthread/files/0001-coex-buff-issue-fix.patch
@@ -0,0 +1,13 @@
+diff --git a/src/core/config/misc.h b/src/core/config/misc.h
+index 27a11e806..c1fae385f 100644
+--- a/src/core/config/misc.h
++++ b/src/core/config/misc.h
+@@ -156,7 +156,7 @@
+  *
+  */
+ #ifndef OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS
+-#define OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS 44
++#define OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS 200
+ #endif
+ 
+ /**
diff --git a/recipes-openthread/openthread/files/0002-csl-debug_prints.patch b/recipes-openthread/openthread/files/0002-csl-debug_prints.patch
new file mode 100644
index 0000000..b45dba9
--- /dev/null
+++ b/recipes-openthread/openthread/files/0002-csl-debug_prints.patch
@@ -0,0 +1,45 @@
+diff --git a/src/core/mac/mac.cpp b/src/core/mac/mac.cpp
+index 7e2f6503c..19ec01411 100644
+--- a/src/core/mac/mac.cpp
++++ b/src/core/mac/mac.cpp
+@@ -2272,9 +2272,12 @@ void Mac::ProcessCsl(const RxFrame &aFrame, const Address &aSrcAddr)
+     child->SetCslSynchronized(true);
+     child->SetCslLastHeard(TimerMilli::GetNow());
+     child->SetLastRxTimestamp(aFrame.GetTimestamp());
+-    LogDebg("Timestamp=%u Sequence=%u CslPeriod=%hu CslPhase=%hu TransmitPhase=%hu",
+-            static_cast<uint32_t>(aFrame.GetTimestamp()), aFrame.GetSequence(), csl->GetPeriod(), csl->GetPhase(),
+-            child->GetCslPhase());
++//    LogDebg("Timestamp=%u Sequence=%u CslPeriod=%hu CslPhase=%hu TransmitPhase=%hu",
++//            static_cast<uint32_t>(aFrame.GetTimestamp()), aFrame.GetSequence(), csl->GetPeriod(), csl->GetPhase(),
++//            child->GetCslPhase());
++    LogDebg("Timestamp=%llu Sequence=%u CslPeriod=%hu CslPhase=%hu TransmitPhase=%hu",
++                 aFrame.GetTimestamp(), aFrame.GetSequence(), csl->GetPeriod(), csl->GetPhase(),
++                  child->GetCslPhase());
+ 
+     Get<CslTxScheduler>().Update();
+ 
+diff --git a/src/core/thread/csl_tx_scheduler.cpp b/src/core/thread/csl_tx_scheduler.cpp
+index 15beb59b9..2094f3f42 100644
+--- a/src/core/thread/csl_tx_scheduler.cpp
++++ b/src/core/thread/csl_tx_scheduler.cpp
+@@ -162,6 +162,8 @@ uint32_t CslTxScheduler::GetNextCslTransmissionDelay(const Child &aChild, uint32
+ 
+     aDelayFromLastRx = static_cast<uint32_t>(nextTxWindow - aChild.GetLastRxTimestamp());
+ 
++    otLogInfoPlat("CSL radioNow = %llu, periodInUS = %hu,firstTXWindow = %llu, nextTxWindow = %llu, aDelayFromLastRx = %u, lastRxTimeStamp = %llu", radioNow, periodInUs, firstTxWindow, nextTxWindow, aDelayFromLastRx,aChild.GetLastRxTimestamp());
++
+     return static_cast<uint32_t>(nextTxWindow - radioNow - mCslFrameRequestAheadUs);
+ }
+ 
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index c6c02e288..000f59555 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -2204,6 +2204,7 @@ exit:
+ template <typename InterfaceType, typename ProcessContextType>
+ uint64_t RadioSpinel<InterfaceType, ProcessContextType>::GetNow(void)
+ {
++    otLogDebgPlat("mIsTimeSynced = %d, otPlatTimeGet = %llu, mRadioTimeOffset = %u",mIsTimeSynced, otPlatTimeGet(), mRadioTimeOffset);
+     return mIsTimeSynced ? (otPlatTimeGet() + static_cast<uint64_t>(mRadioTimeOffset)) : UINT64_MAX;
+ }
+ 
diff --git a/recipes-openthread/openthread/files/0003-set-vsc-ir-eui64.patch b/recipes-openthread/openthread/files/0003-set-vsc-ir-eui64.patch
new file mode 100644
index 0000000..a0b265c
--- /dev/null
+++ b/recipes-openthread/openthread/files/0003-set-vsc-ir-eui64.patch
@@ -0,0 +1,245 @@
+From 3d8788a3faba54b269717cb12267b338143054d1 Mon Sep 17 00:00:00 2001
+From: Sylvain Potel <sylvain.potel@nxp.com>
+Date: Thu, 19 May 2022 11:56:37 +0200
+Subject: Issue WSW-19369 Add API to Set IEEE.802.15.4 MAC Address if RCP does
+ not provide persistent storage (seteui64). Add APIs to configure and set
+ Independent Reset in ot-ctl as well.
+
+
+diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
+index 2d7a654b9..521513811 100644
+--- a/include/openthread/platform/radio.h
++++ b/include/openthread/platform/radio.h
+@@ -1144,11 +1144,19 @@ otError otPlatRadioConfigureEnhAckProbing(otInstance *        aInstance,
+  * @}
+  *
+  */
++void otPlatRadioSetIRCmd(otInstance *aInstance);
+ 
+ /**
+  * @}
+  *
+  */
++void otPlatRadioSetIRConfig(otInstance *aInstance, uint8_t mode);
++
++/**
++ * @}
++ *
++ */
++otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeeeEui64);
+ 
+ #ifdef __cplusplus
+ } // end of extern "C"
+diff --git a/src/lib/spinel/radio_spinel.hpp b/src/lib/spinel/radio_spinel.hpp
+index 7953a2b8d..ab12766cd 100644
+--- a/src/lib/spinel/radio_spinel.hpp
++++ b/src/lib/spinel/radio_spinel.hpp
+@@ -174,6 +174,18 @@ public:
+      */
+     otError GetIeeeEui64(uint8_t *aIeeeEui64);
+ 
++    /**
++     * This method sets the factory-assigned IEEE EUI-64 for this transceiver.
++     *
++     * @param[in]  aInstance   The OpenThread instance structure.
++     * @param[out] aIeeeEui64  A pointer to the factory-assigned IEEE EUI-64.
++     *
++     * @retval  OT_ERROR_NONE               Succeeded.
++     * @retval  OT_ERROR_INVALID_STATE      Failed EUI64 is set by factory only except if OTP is not supported.
++     * 
++     */
++    otError SetIeeeEui64(const otExtAddress &aIeeeEui64);
++
+     /**
+      * This method sets the Extended Address for address filtering.
+      *
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index 9faf91548..744d05b77 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -1204,6 +1204,23 @@ otError RadioSpinel<InterfaceType, ProcessContextType>::GetIeeeEui64(uint8_t *aI
+     return OT_ERROR_NONE;
+ }
+ 
++template <typename InterfaceType, typename ProcessContextType>
++otError RadioSpinel<InterfaceType, ProcessContextType>::SetIeeeEui64(const otExtAddress &aIeeeEui64)
++{
++    otExtAddress addr;
++    otError      error;
++
++    for (size_t i = 0; i < sizeof(addr); i++)
++    {
++        addr.m8[i] = aIeeeEui64.m8[sizeof(addr) - 1 - i];
++    }
++
++    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD, SPINEL_DATATYPE_EUI64_S, addr.m8));
++    mIeeeEui64 = aIeeeEui64;
++exit:
++    return error;
++}
++
+ template <typename InterfaceType, typename ProcessContextType>
+ otError RadioSpinel<InterfaceType, ProcessContextType>::SetExtendedAddress(const otExtAddress &aExtAddress)
+ {
+diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
+index 8b6db66fa..12187031e 100644
+--- a/src/lib/spinel/spinel.h
++++ b/src/lib/spinel/spinel.h
+@@ -4748,6 +4748,11 @@ enum
+     SPINEL_PROP_NEST__END = 0x3C00,
+ 
+     SPINEL_PROP_VENDOR__BEGIN = 0x3C00,
++
++    SPINEL_PROP_VENDOR_NXP_IR_CONFIG     = (SPINEL_PROP_VENDOR__BEGIN + 0x100),
++    SPINEL_PROP_VENDOR_NXP_IR_CMD        = (SPINEL_PROP_VENDOR__BEGIN + 0x101),
++    SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10A),
++
+     SPINEL_PROP_VENDOR__END   = 0x4000,
+ 
+     SPINEL_PROP_VENDOR_ESP__BEGIN = (SPINEL_PROP_VENDOR__BEGIN + 0),
+diff --git a/src/posix/main.c b/src/posix/main.c
+index ebecb4777..08d4dc5ac 100644
+--- a/src/posix/main.c
++++ b/src/posix/main.c
+@@ -352,11 +352,108 @@ static void ProcessExit(void *aContext, uint8_t aArgsLength, char *aArgs[])
+ }
+ #endif
+ 
++// 15.4_INDEPENDENT_RESET
++static void ProcessIRConfig(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    syslog(LOG_INFO, "ProcessIRConfig");
++
++    if( aArgsLength == 1 )
++    {
++        uint16_t mode = (uint16_t)atoi(aArgs[0]);
++        syslog(LOG_INFO, "-> mode %s", mode==0 ? "Disable IR":(mode==1 ?("OOB IR"):"InBand IR"));
++        if( mode < 3 )
++        {
++            otPlatRadioSetIRConfig(aContext, mode);
++            syslog(LOG_INFO, "ProcessIRConfig DONE");
++        }
++    }
++    else
++    {
++        syslog(LOG_INFO, "ProcessIRConfig FAILED!");
++    }
++}
++
++static void ProcessIRCmd(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    OT_UNUSED_VARIABLE(aArgsLength);
++    OT_UNUSED_VARIABLE(aArgs);
++    syslog(LOG_INFO, "ProcessIRCmd");
++    otPlatRadioSetIRCmd(aContext);
++    syslog(LOG_INFO, "ProcessIRCmd DONE");
++}
++
++static void ProcessSetEui64(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    if( aArgsLength == 1 )
++    {
++        otExtAddress addr;
++        char        *hex  = *aArgs;
++
++        syslog(LOG_INFO, "+ SetEui64 %s (len %d)", *aArgs, (uint32_t)strlen(*aArgs));
++
++        if( (hex[1] == 'x') && (strlen(*aArgs) == 18) )
++        {
++            otError error = OT_ERROR_NONE;
++
++            hex = hex + 2;
++
++            for(uint32_t i = 0; (i < 8) && (error == OT_ERROR_NONE); i++)
++            {
++                addr.m8[i] = 0;
++                for(uint32_t k = 0; k < 2; k++)
++                {
++                    // get current character then increment
++                    uint8_t byte = *hex++;
++                    // transform hex character to the 4bit equivalent number, using the ascii table indexes
++                    if (byte >= '0' && byte <= '9')
++                        byte = byte - '0';
++                    else if (byte >= 'a' && byte <='f')
++                        byte = byte - 'a' + 10;
++                    else if (byte >= 'A' && byte <='F')
++                        byte = byte - 'A' + 10;
++                    else
++                    {
++                        error = OT_ERROR_FAILED;
++                        break;
++                    }
++                    // shift 4 to make space for new digit, and add the 4 bits of the new digit
++                    addr.m8[i] = (addr.m8[i] << 4) | (byte & 0xF);
++                }
++            }
++
++            if( error == OT_ERROR_NONE )
++            {
++                error = otPlatRadioSetIeeeEui64(aContext, (const otExtAddress*)&addr);
++            }
++
++            if( error != OT_ERROR_NONE )
++            {
++                syslog(LOG_INFO, "- SetEui64 Failed (%#x)", error);
++            }
++            else
++            {
++                syslog(LOG_INFO, "- SetEui64 SUCCESS");
++            }
++        }
++        else
++        {
++            syslog(LOG_INFO, "- SetEui64 invalid input arg (0x....?) !");
++        }
++    }
++    else
++    {
++        syslog(LOG_INFO, "- SetEui64 FAILED !");
++    }
++}
++
+ static const otCliCommand kCommands[] = {
+ #if !OPENTHREAD_POSIX_CONFIG_DAEMON_ENABLE
+     {"exit", ProcessExit},
+ #endif
+     {"netif", ProcessNetif},
++    {"ircfg", ProcessIRConfig},    //=> OutOfBand Independent Reset Configuration ircfg <1> means OOB mode
++    {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
++    {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
+ };
+ 
+ int main(int argc, char *argv[])
+diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
+index 410975272..db5cadda9 100644
+--- a/src/posix/platform/radio.cpp
++++ b/src/posix/platform/radio.cpp
+@@ -639,3 +639,27 @@ otError otPlatRadioReceiveAt(otInstance *aInstance, uint8_t aChannel, uint32_t a
+     OT_UNUSED_VARIABLE(aDuration);
+     return OT_ERROR_NOT_IMPLEMENTED;
+ }
++
++void otPlatRadioSetIRConfig(otInstance *aInstance, uint8_t mode)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    SuccessOrDie(sRadioSpinel.Set(SPINEL_PROP_VENDOR_NXP_IR_CONFIG, SPINEL_DATATYPE_UINT16_S, mode));
++}
++void otPlatRadioSetIRCmd(otInstance *aInstance)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    SuccessOrDie(sRadioSpinel.Set(SPINEL_PROP_VENDOR_NXP_IR_CMD, SPINEL_DATATYPE_UINT16_S));
++}
++
++otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeeeEui64)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    otExtAddress addr;
++
++    for (size_t i = 0; i < sizeof(addr); i++)
++    {
++        addr.m8[i] = aIeeeEui64->m8[sizeof(addr) - 1 - i];
++    }
++
++    return sRadioSpinel.SetIeeeEui64(*aIeeeEui64);
++}
+\ No newline at end of file
diff --git a/recipes-openthread/openthread/files/0004-set-vsc-txpwr-limit.patch b/recipes-openthread/openthread/files/0004-set-vsc-txpwr-limit.patch
new file mode 100644
index 0000000..a446db2
--- /dev/null
+++ b/recipes-openthread/openthread/files/0004-set-vsc-txpwr-limit.patch
@@ -0,0 +1,130 @@
+diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
+index 2a1252c04..ba61d1373 100644
+--- a/include/openthread/platform/radio.h
++++ b/include/openthread/platform/radio.h
+@@ -1158,6 +1158,12 @@ void otPlatRadioSetIRConfig(otInstance *aInstance, uint8_t mode);
+  */
+ otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeeeEui64);
+ 
++/**
++ * @}
++ *
++ */
++otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit);
++
+ #ifdef __cplusplus
+ } // end of extern "C"
+ #endif
+diff --git a/src/lib/spinel/radio_spinel.hpp b/src/lib/spinel/radio_spinel.hpp
+index 23810a9ef..1605e5cd3 100644
+--- a/src/lib/spinel/radio_spinel.hpp
++++ b/src/lib/spinel/radio_spinel.hpp
+@@ -186,6 +186,18 @@ public:
+      */
+     otError SetIeeeEui64(const otExtAddress &aIeeeEui64);
+ 
++    /**
++     * @brief Set the Tx Power Limit for 15.4
++     *
++     * @param txPowerLimit
++     * txPowerLimit (0 or higher than 22), No power backoff is applied
++     * txPowerLimit = 1 to 44, force TX power back off to txPowerLimit
++     * (txPowerLimit = 0.5dBm step, TX power back off : 0.5dBm step )
++     *
++     * @return otError
++     */
++    otError SetTxPowerLimit(uint8_t txPowerLimit);
++
+     /**
+      * This method sets the Extended Address for address filtering.
+      *
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index 4448e0e93..c0b950e01 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -1221,6 +1221,16 @@ exit:
+     return error;
+ }
+ 
++template <typename InterfaceType, typename ProcessContextType>
++otError RadioSpinel<InterfaceType, ProcessContextType>::SetTxPowerLimit(uint8_t txPowerLimit)
++{
++    otError error;
++    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, txPowerLimit));
++
++exit:
++    return error;
++}
++
+ template <typename InterfaceType, typename ProcessContextType>
+ otError RadioSpinel<InterfaceType, ProcessContextType>::SetExtendedAddress(const otExtAddress &aExtAddress)
+ {
+diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
+index 130698a7a..48004460b 100644
+--- a/src/lib/spinel/spinel.h
++++ b/src/lib/spinel/spinel.h
+@@ -4770,6 +4770,7 @@ enum
+     SPINEL_PROP_VENDOR_NXP_IR_CONFIG     = (SPINEL_PROP_VENDOR__BEGIN + 0x100),
+     SPINEL_PROP_VENDOR_NXP_IR_CMD        = (SPINEL_PROP_VENDOR__BEGIN + 0x101),
+     SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10A),
++    SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10B),
+ 
+     SPINEL_PROP_VENDOR__END   = 0x4000,
+ 
+diff --git a/src/posix/main.c b/src/posix/main.c
+index 7a12a59ac..317300b94 100644
+--- a/src/posix/main.c
++++ b/src/posix/main.c
+@@ -439,6 +439,27 @@ static void ProcessSetEui64(void *aContext, uint8_t aArgsLength, char *aArgs[])
+     }
+ }
+ 
++static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    syslog(LOG_INFO, "SetTxPowerLimit");
++
++    if( aArgsLength == 1 )
++    {
++        uint8_t txPowerLimit = (uint8_t)atoi(aArgs[0]);
++        if((txPowerLimit>=1)&&(txPowerLimit<=22)){
++            syslog(LOG_INFO, "-> txPowerLimit : %d", txPowerLimit);
++        }else{
++            syslog(LOG_INFO, "-> txPowerLimit : default value");
++        }
++        otPlatRadioSetTxPowerLimit(aContext, txPowerLimit);
++        syslog(LOG_INFO, "SetTxPowerLimit DONE");
++    }
++    else
++    {
++        syslog(LOG_INFO, "SetTxPowerLimit FAILED! Invalid input arg");
++    }
++}
++
+ static const otCliCommand kCommands[] = {
+ #if !OPENTHREAD_POSIX_CONFIG_DAEMON_ENABLE
+     {"exit", ProcessExit},
+@@ -447,6 +468,7 @@ static const otCliCommand kCommands[] = {
+     {"ircfg", ProcessIRConfig},    //=> OutOfBand Independent Reset Configuration ircfg <1> means OOB mode
+     {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
+     {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
++    {"txpwrlimit", ProcessSetTxPowerLimit}, //=> Set TX power limit for 15.4
+ };
+ 
+ int main(int argc, char *argv[])
+diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
+index d7c817483..d6cc7f6fe 100644
+--- a/src/posix/platform/radio.cpp
++++ b/src/posix/platform/radio.cpp
+@@ -683,4 +683,10 @@ otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeee
+     }
+ 
+     return sRadioSpinel.SetIeeeEui64(*aIeeeEui64);
+-}
+\ No newline at end of file
++}
++
++otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    return sRadioSpinel.SetTxPowerLimit(txPowerLimit);
++}
diff --git a/recipes-openthread/openthread/files/0005-host-spi-clear-tx-buffer.patch b/recipes-openthread/openthread/files/0005-host-spi-clear-tx-buffer.patch
new file mode 100644
index 0000000..02dc771
--- /dev/null
+++ b/recipes-openthread/openthread/files/0005-host-spi-clear-tx-buffer.patch
@@ -0,0 +1,19 @@
+From 2ee6d02119bd9a89c0d122abd551d69df57868e7 Mon Sep 17 00:00:00 2001
+From: Guillaume Legoupil <guillaume.legoupil@nxp.com>
+Date: Mon, 4 Jul 2022 09:28:17 +0200
+Subject: Spi Host: clear tx buffer
+
+
+diff --git a/src/posix/platform/spi_interface.cpp b/src/posix/platform/spi_interface.cpp
+index 752dd44c1..e805b548c 100644
+--- a/src/posix/platform/spi_interface.cpp
++++ b/src/posix/platform/spi_interface.cpp
+@@ -598,6 +598,8 @@ otError SpiInterface::PushPullSpi(void)
+             mSpiTxFrameByteCount += mSpiTxPayloadSize;
+ 
+             mSpiTxIsReady      = false;
++            // Clear tx buffer after usage
++            memset(&mSpiTxFrameBuffer[kSpiFrameHeaderSize], 0, mSpiTxPayloadSize);
+             mSpiTxPayloadSize  = 0;
+             mSpiTxRefusedCount = 0;
+         }
diff --git a/recipes-openthread/openthread/files/0006-ot-daemon-release-resources.patch b/recipes-openthread/openthread/files/0006-ot-daemon-release-resources.patch
new file mode 100644
index 0000000..dbe04ab
--- /dev/null
+++ b/recipes-openthread/openthread/files/0006-ot-daemon-release-resources.patch
@@ -0,0 +1,43 @@
+From ac5a4479f73619c6aad9ef06b1cc7711694db110 Mon Sep 17 00:00:00 2001
+From: Guillaume Legoupil <guillaume.legoupil@nxp.com>
+Date: Mon, 18 Jul 2022 11:48:02 +0200
+Subject: ot-daemon: release resources before leaving
+
+
+diff --git a/src/posix/platform/hdlc_interface.cpp b/src/posix/platform/hdlc_interface.cpp
+index 391fdacd5..6fce71867 100644
+--- a/src/posix/platform/hdlc_interface.cpp
++++ b/src/posix/platform/hdlc_interface.cpp
+@@ -182,6 +182,7 @@ HdlcInterface::~HdlcInterface(void)
+ 
+ void HdlcInterface::Deinit(void)
+ {
++    otLogDebgPlat("Deinit: close %s", (mSockFd >= 0)?("Radio "):(""));
+     CloseFile();
+ }
+ 
+diff --git a/src/posix/platform/spi_interface.cpp b/src/posix/platform/spi_interface.cpp
+index 752dd44c1..eb4a129e7 100644
+--- a/src/posix/platform/spi_interface.cpp
++++ b/src/posix/platform/spi_interface.cpp
+@@ -204,6 +204,7 @@ SpiInterface::~SpiInterface(void)
+ 
+ void SpiInterface::Deinit(void)
+ {
++    otLogDebgPlat("Deinit: close %s%s%s", (mSpiDevFd >= 0)?("SpiDev "):(""), (mResetGpioValueFd >= 0)?("ResetGpio "):(""), (mIntGpioValueFd >= 0)?("IntGpio "):(""));
+     if (mSpiDevFd >= 0)
+     {
+         close(mSpiDevFd);
+diff --git a/src/posix/platform/system.cpp b/src/posix/platform/system.cpp
+index c3e176abe..3cfb20d52 100644
+--- a/src/posix/platform/system.cpp
++++ b/src/posix/platform/system.cpp
+@@ -125,6 +125,8 @@ void platformInit(otPlatformConfig *aPlatformConfig)
+     platformAlarmInit(aPlatformConfig->mSpeedUpFactor, aPlatformConfig->mRealTimeSignal);
+     platformRadioInit(get802154RadioUrl(aPlatformConfig));
+ 
++    atexit(&platformRadioDeinit);
++
+     // For Dry-Run option, only init the radio.
+     VerifyOrExit(!aPlatformConfig->mDryRun);
+ 
diff --git a/recipes-openthread/openthread/files/0008-add-mfg-cmd-for-pfw.patch b/recipes-openthread/openthread/files/0008-add-mfg-cmd-for-pfw.patch
new file mode 100644
index 0000000..5be4227
--- /dev/null
+++ b/recipes-openthread/openthread/files/0008-add-mfg-cmd-for-pfw.patch
@@ -0,0 +1,420 @@
+From 98c298926f14ec1d4ae29cde63280a127f42c0ba Mon Sep 17 00:00:00 2001
+From: Maele Philippot <maele.philippot@nxp.com>
+Date: Thu, 11 Aug 2022 11:28:55 +0200
+Subject: [PATCH 1/1] Issue: WSW-19668 [IW512] Add RF testing features support to PFW (only supported in MFG for now)
+Add MFG vendor specific command to enable RF testing using ot-ctl.
+
+---
+ include/openthread/platform/radio.h  |   6 +
+ src/lib/spinel/radio_spinel.hpp      |   7 +
+ src/lib/spinel/radio_spinel_impl.hpp |  15 ++
+ src/lib/spinel/spinel.h              |   1 +
+ src/posix/main.c                     | 284 ++++++++++++++++++++++++++-
+ src/posix/platform/radio.cpp         |   6 +
+ 6 files changed, 318 insertions(+), 1 deletion(-)
+
+diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
+index ba61d1373..c9c94e430 100644
+--- a/include/openthread/platform/radio.h
++++ b/include/openthread/platform/radio.h
+@@ -1164,6 +1164,12 @@ otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeee
+  */
+ otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit);
+ 
++/**
++ * @}
++ *
++ */
++otError otPlatRadioMfgCommand(otInstance *aInstance, uint8_t *payload, const uint8_t payloadLenIn, uint8_t *payloadLenOut);
++
+ #ifdef __cplusplus
+ } // end of extern "C"
+ #endif
+diff --git a/src/lib/spinel/radio_spinel.hpp b/src/lib/spinel/radio_spinel.hpp
+index 2505e524b..1664e2ff2 100644
+--- a/src/lib/spinel/radio_spinel.hpp
++++ b/src/lib/spinel/radio_spinel.hpp
+@@ -198,6 +198,13 @@ public:
+      */
+     otError SetTxPowerLimit(uint8_t txPowerLimit);
+ 
++    /**
++     * @brief GetMfgChannel
++     * @param channel
++     * @return otError
++     */
++    otError MfgCmd(uint8_t *payload, const uint8_t payloadLenIn, uint8_t &payloadLenOut);
++
+     /**
+      * This method sets the Extended Address for address filtering.
+      *
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index ce88ea8a0..32a4cc1f2 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -1231,6 +1231,21 @@ exit:
+     return error;
+ }
+ 
++#define MAXBUFFERSIZE 16
++
++template <typename InterfaceType, typename ProcessContextType>
++otError RadioSpinel<InterfaceType, ProcessContextType>::MfgCmd(uint8_t *payload, const uint8_t payloadLenIn, uint8_t &payloadLenOut)
++{
++    otError error;
++    uint8_t buffer[MAXBUFFERSIZE]; //temporary buffer used to be passed as arg of GetWithParam
++    spinel_ssize_t packed;
++
++    packed = spinel_datatype_pack(buffer, sizeof(buffer), SPINEL_DATATYPE_DATA_S, payload, payloadLenIn);
++    error = GetWithParam(SPINEL_CMD_VENDOR_NXP_MFG, buffer, static_cast<spinel_size_t>(packed), SPINEL_DATATYPE_DATA_S, payload, &payloadLenOut);
++
++    return error;
++}
++
+ template <typename InterfaceType, typename ProcessContextType>
+ otError RadioSpinel<InterfaceType, ProcessContextType>::SetExtendedAddress(const otExtAddress &aExtAddress)
+ {
+diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
+index aa738cfa2..cf1a4d56b 100644
+--- a/src/lib/spinel/spinel.h
++++ b/src/lib/spinel/spinel.h
+@@ -4771,6 +4771,7 @@ enum
+     SPINEL_PROP_VENDOR_NXP_IR_CMD        = (SPINEL_PROP_VENDOR__BEGIN + 0x101),
+     SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10A),
+     SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10B),
++    SPINEL_CMD_VENDOR_NXP_MFG  = (SPINEL_CMD_VENDOR__BEGIN + 0x3FF),
+ 
+     SPINEL_PROP_VENDOR__END   = 0x4000,
+ 
+diff --git a/src/posix/main.c b/src/posix/main.c
+index c8f9c589b..ed7cd99db 100644
+--- a/src/posix/main.c
++++ b/src/posix/main.c
+@@ -70,6 +70,25 @@
+ 
+ #include "lib/platform/reset_util.h"
+ 
++#define MFG_CMD_ACTION_GET 0
++#define MFG_CMD_ACTION_SET 1
++
++#define MFG_CMD_GET_SET_CHANNEL 0x0b      // 11
++#define MFG_CMD_GET_SET_TXPOWER 0x0f      // 15
++#define MFG_CMD_CONTINUOUS_TX 0x11        // 17
++#define MFG_CMD_GET_SET_PAYLOAD_SIZE 0x14 // 20
++#define MFG_CMD_GET_RX_RESULT 0x1f        // 31
++#define MFG_CMD_START_RX_TEST 0x20        // 32
++#define MFG_CMD_BURST_TX 0x21             // 33
++#define MFG_CMD_DUTY_CYCLE_TX 0x23        // 35
++#define MFG_CMD_GET_SET_CCA_THRESHOLD  0x2F   // 47
++#define MFG_CMD_CONTINOUS_CCA_TEST 0X31   //49
++#define MFG_CMD_GET_CCA_STATUS 0x32       //50
++#define MFG_CMD_CONTINOUS_ED_TEST 0x37    //55
++#define MFG_CMD_GET_ED_VALUE    0x38      //56
++
++uint8_t mfgEnable = 0;
++
+ /**
+  * This function initializes NCP app.
+  *
+@@ -446,7 +465,7 @@ static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aA
+     if( aArgsLength == 1 )
+     {
+         uint8_t txPowerLimit = (uint8_t)atoi(aArgs[0]);
+-        if((txPowerLimit>=1)&&(txPowerLimit<=22)){
++        if((txPowerLimit>=1)&&(txPowerLimit<=44)){
+             syslog(LOG_INFO, "-> txPowerLimit : %d", txPowerLimit);
+         }else{
+             syslog(LOG_INFO, "-> txPowerLimit : default value");
+@@ -460,6 +479,268 @@ static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aA
+     }
+ }
+ 
++static otError ProcessMfgGetInt8(void *aContext, uint8_t cmdId, uint8_t aArgsLength)
++{
++    otError error = OT_ERROR_INVALID_ARGS;
++    uint8_t outputLen = 0;
++    uint8_t payload[12] = {11};
++    uint8_t payloadLen = 12;
++
++    if(aArgsLength == 1)
++    {
++        payload[1] = cmdId;
++        payload[2] = MFG_CMD_ACTION_GET;
++
++        otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++
++        if((outputLen >= 5) && (payload[3] == 0))
++        {
++            otCliOutputFormat("%d\r\n", (int8_t)payload[4]);
++            error = OT_ERROR_NONE;
++        }
++        else{
++            error = OT_ERROR_FAILED;
++        }
++    }
++
++    return error;
++}
++
++static otError ProcessMfgSetInt8(void *aContext, uint8_t cmdId, uint8_t aArgsLength, char *aArgs[], int8_t min, int8_t max)
++{
++    otError error = OT_ERROR_INVALID_ARGS;
++    uint8_t outputLen = 0;
++    uint8_t payload[12] = {11};
++    uint8_t payloadLen = 12;
++    int8_t setValue = 0;
++
++    if(aArgsLength == 2)
++    {
++        setValue = (int8_t)atoi(aArgs[1]);
++        if((setValue >= min) && (setValue <= max))
++        {
++            payload[1] = cmdId;
++            payload[2] = MFG_CMD_ACTION_SET;
++            payload[4] = (uint8_t)setValue;
++
++            otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++
++            if((outputLen >= 4) && (payload[3] == 0))
++            {
++                error = OT_ERROR_NONE;
++            }
++            else
++            {
++                error = OT_ERROR_FAILED;
++            }
++        }
++    }
++
++    return error;
++}
++
++static void ProcessMfgCommands(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    uint8_t payload[12] = {11};
++    uint8_t payloadLen = 12;
++    uint8_t outputLen = 0;
++    otError error = OT_ERROR_INVALID_ARGS;
++    uint8_t cmdId, idx;
++
++    if(aArgsLength == 1)
++    {
++        cmdId = (uint8_t)atoi(aArgs[0]);
++        if((cmdId == 0)||(cmdId == 1))
++        {
++            mfgEnable = cmdId;
++            syslog(LOG_INFO, "MFG command SUCCESS");
++            return;
++        }
++    }
++
++    if(mfgEnable == 0)
++    {
++        syslog(LOG_INFO, "MFG command not enabled");
++        otCliOutputFormat("MFG command not enabled. to enable it : mfgcmd 1\r\n");
++        return;
++    }
++
++    if ((aArgsLength > 0) && (mfgEnable == 1))
++    {
++        cmdId = (uint8_t)atoi(aArgs[0]);
++
++        switch (cmdId)
++        {
++        case MFG_CMD_GET_SET_CHANNEL: // get channel
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_SET_CHANNEL, aArgsLength);
++            break;
++
++        case MFG_CMD_GET_SET_CHANNEL + 1: // set channel
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_GET_SET_CHANNEL, aArgsLength, aArgs, 11, 26);
++            break;
++
++        case MFG_CMD_GET_SET_TXPOWER: // get txpower
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_SET_TXPOWER, aArgsLength);
++            break;
++
++        case MFG_CMD_GET_SET_TXPOWER + 1: // set txpower
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_GET_SET_TXPOWER, aArgsLength, aArgs, -40, 44);
++            break;
++
++        case MFG_CMD_CONTINUOUS_TX:
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_CONTINUOUS_TX, aArgsLength, aArgs, 0, 1);
++            break;
++
++        case MFG_CMD_GET_SET_PAYLOAD_SIZE: // get
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_SET_PAYLOAD_SIZE, aArgsLength);
++            break;
++
++        case MFG_CMD_GET_SET_PAYLOAD_SIZE + 1: // set
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_GET_SET_PAYLOAD_SIZE, aArgsLength, aArgs, 0, 127);
++            // actual limits are set in MFG function and error is return in case of wrong parameter
++            break;
++
++        case MFG_CMD_GET_RX_RESULT:
++        {
++            if(aArgsLength == 1)
++            {
++                payload[1] = MFG_CMD_GET_RX_RESULT;
++                payload[2] = MFG_CMD_ACTION_GET;
++                otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++                if(outputLen >= 11)
++                {
++                    otCliOutputFormat("status : %d\r\n", payload[4]);
++                    otCliOutputFormat("rx_pkt_count : %d\r\n", payload[5]|(payload[6]<<8));
++                    otCliOutputFormat("total_pkt_count : %d\r\n", payload[7]|(payload[8]<<8));
++                    otCliOutputFormat("rssi : %d\r\n",(int8_t)payload[9]);
++                    otCliOutputFormat("lqi : %d\r\n", payload[10]);
++                    error = OT_ERROR_NONE;
++                }
++                else{
++                    error = OT_ERROR_FAILED;
++                }
++            }
++        }
++        break;
++
++        case MFG_CMD_START_RX_TEST:
++        {
++            if(aArgsLength == 1)
++            {
++                payload[1] = MFG_CMD_START_RX_TEST;
++                otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++                error = OT_ERROR_NONE;
++            }
++        }
++        break;
++
++        case MFG_CMD_BURST_TX:
++        {
++            uint8_t mode = 0;
++            if(aArgsLength == 3)
++            {
++                mode = (uint8_t)atoi(aArgs[1]);
++                if(mode < 8)
++                {
++                    payload[1] = MFG_CMD_BURST_TX;
++                    payload[4] = mode;
++                    payload[5] = (uint8_t)atoi(aArgs[2]);
++                    otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++                    error = OT_ERROR_NONE;
++                }
++            }
++        }
++        break;
++
++        case MFG_CMD_DUTY_CYCLE_TX:
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_DUTY_CYCLE_TX, aArgsLength, aArgs, 0, 1);
++            break;
++
++        case MFG_CMD_GET_SET_CCA_THRESHOLD: // get
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_SET_CCA_THRESHOLD, aArgsLength);
++            break;
++
++        case MFG_CMD_GET_SET_CCA_THRESHOLD + 1: // set
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_GET_SET_CCA_THRESHOLD, aArgsLength, aArgs, -110, 0);
++            break;
++
++        case MFG_CMD_CONTINOUS_CCA_TEST:
++        {
++            if(aArgsLength == 3)
++            {
++                payload[1] = MFG_CMD_CONTINOUS_CCA_TEST;
++                payload[2] = MFG_CMD_ACTION_SET;
++                payload[4] = (uint8_t)atoi(aArgs[1]);
++                payload[5] = (uint8_t)atoi(aArgs[2]);
++                otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++                if((outputLen >= 4) && (payload[3] == 0))
++                {
++                    error = OT_ERROR_NONE;
++                }
++                else{
++                    error = OT_ERROR_FAILED;
++                }
++            }
++        }
++        break;
++
++        case MFG_CMD_GET_CCA_STATUS: // get
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_CCA_STATUS, aArgsLength);
++            break;
++
++        case MFG_CMD_CONTINOUS_ED_TEST:
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_CONTINOUS_ED_TEST, aArgsLength, aArgs, -127, 127);
++            break;
++
++        case MFG_CMD_GET_ED_VALUE:
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_ED_VALUE, aArgsLength);
++            break;
++
++        default:
++            error = OT_ERROR_NOT_IMPLEMENTED;
++            break;
++        }
++    }
++
++    //HANDLE ERRORS
++    if(error == OT_ERROR_NONE)
++    {
++        syslog(LOG_INFO, "MFG command SUCCESS");
++    }
++    else if(aArgsLength == payloadLen)
++    {
++        // If user passed all the payload, this means this is a direct message for the RCP.
++        // Send it and print the return results.
++        for(idx = 0; idx < payloadLen; idx++)
++        {
++            payload[idx] = (uint8_t)atoi(aArgs[idx]);
++        }
++        otPlatRadioMfgCommand(aContext, (uint8_t *)payload, payloadLen, &outputLen);
++        for(idx = 0; idx < outputLen; idx++)
++        {
++            otCliOutputFormat("%d ", payload[idx]);
++        }
++        otCliOutputFormat("\r\n");
++        error = OT_ERROR_NONE;
++        syslog(LOG_INFO, "MFG command SUCCESS");
++    }
++    else if(error == OT_ERROR_INVALID_ARGS)
++    {
++        syslog(LOG_INFO, "MFG command Invalid parameter");
++        otCliOutputFormat("INVALID PARAMETER\r\n");
++    }
++    else if(error == OT_ERROR_NOT_IMPLEMENTED)
++    {
++        syslog(LOG_INFO, "MFG command not implemented");
++        otCliOutputFormat("NOT IMPLEMENTED\r\n");
++    }
++    else
++    {
++        syslog(LOG_INFO, "MFG command FAILED");
++        otCliOutputFormat("FAILED\r\n");
++    }
++}
++
+ static const otCliCommand kCommands[] = {
+ #if !OPENTHREAD_POSIX_CONFIG_DAEMON_ENABLE
+     {"exit", ProcessExit},
+@@ -469,6 +750,7 @@ static const otCliCommand kCommands[] = {
+     {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
+     {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
+     {"txpwrlimit", ProcessSetTxPowerLimit}, //=> Set TX power limit for 15.4
++    {"mfgcmd", ProcessMfgCommands} //=> Generic VSC for MFG RF commands
+ };
+ 
+ int main(int argc, char *argv[])
+diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
+index 9e2b6e11a..7f84d3ffc 100644
+--- a/src/posix/platform/radio.cpp
++++ b/src/posix/platform/radio.cpp
+@@ -690,3 +690,9 @@ otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit)
+     OT_UNUSED_VARIABLE(aInstance);
+     return sRadioSpinel.SetTxPowerLimit(txPowerLimit);
+ }
++
++otError otPlatRadioMfgCommand(otInstance *aInstance, uint8_t *payload, const uint8_t payloadLenIn, uint8_t *payloadLenOut)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    return sRadioSpinel.MfgCmd(payload, payloadLenIn, *payloadLenOut);
++}
+-- 
+
diff --git a/recipes-openthread/openthread/files/0010-tcp-connection-war.patch b/recipes-openthread/openthread/files/0010-tcp-connection-war.patch
new file mode 100644
index 0000000..6514c1f
--- /dev/null
+++ b/recipes-openthread/openthread/files/0010-tcp-connection-war.patch
@@ -0,0 +1,40 @@
+diff --git a/src/posix/platform/netif.cpp b/src/posix/platform/netif.cpp
+index 572d59f7b..4dd35bdd0 100644
+--- a/src/posix/platform/netif.cpp
++++ b/src/posix/platform/netif.cpp
+@@ -150,6 +150,15 @@ extern int
+ #include "common/debug.hpp"
+ #include "net/ip6_address.hpp"
+ 
++// TCP reset packet header lenght is 20 bytes and packet header field reserves upper 6 bits
++#define TCP_RST_PKT_HDR_LEN_MASK    (0x14 << 2)
++#define TCP_RST_PKT_HDR_INDEX        52
++#define TCP_RST_PKT_FLAG_INDEX       53
++#define TCP_TH_RST                   0x04
++// Ipv6 reset packet header lenght is 60 bytes
++#define IPV6_RST_PKT_HDR_LEN      60
++#define IPV6_RST_PKT_HDR_INDEX    6
++
+ unsigned int gNetifIndex = 0;
+ char         gNetifName[IFNAMSIZ];
+ 
+@@ -966,8 +975,17 @@ static void processTransmit(otInstance *aInstance)
+ 
+     SuccessOrExit(error = otMessageAppend(message, &packet[offset], static_cast<uint16_t>(rval)));
+ 
+-    error   = otIp6Send(aInstance, message);
+-    message = nullptr;
++    if(!((rval == IPV6_RST_PKT_HDR_LEN) && (packet[IPV6_RST_PKT_HDR_INDEX] == OT_IP6_PROTO_TCP) &&
++        ((packet[TCP_RST_PKT_HDR_INDEX] & 0xFC) == TCP_RST_PKT_HDR_LEN_MASK) &&
++        (packet[TCP_RST_PKT_FLAG_INDEX] & TCP_TH_RST) == TCP_TH_RST))
++    {
++        error   = otIp6Send(aInstance, message);
++        message = nullptr;
++    }
++    else
++    {
++        error = OT_ERROR_DROP;
++    }
+ 
+ exit:
+     if (message != nullptr)
diff --git a/recipes-openthread/openthread/files/0011-get-vsc-txpwr-limit.patch b/recipes-openthread/openthread/files/0011-get-vsc-txpwr-limit.patch
new file mode 100644
index 0000000..abc071a
--- /dev/null
+++ b/recipes-openthread/openthread/files/0011-get-vsc-txpwr-limit.patch
@@ -0,0 +1,142 @@
+diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
+index 83372e27e..a2c47efd4 100644
+--- a/include/openthread/platform/radio.h
++++ b/include/openthread/platform/radio.h
+@@ -1164,6 +1164,11 @@ otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeee
+  *
+  */
+ otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit);
++/**
++ * @}
++ *
++ */
++otError otPlatRadioGetTxPowerLimit(otInstance *aInstance, uint8_t* txPowerLimit);
+
+ /**
+  * @}
+diff --git a/src/lib/spinel/radio_spinel.hpp b/src/lib/spinel/radio_spinel.hpp
+index cff161d99..b2110695a 100644
+--- a/src/lib/spinel/radio_spinel.hpp
++++ b/src/lib/spinel/radio_spinel.hpp
+@@ -198,6 +198,17 @@ public:
+      */
+     otError SetTxPowerLimit(uint8_t txPowerLimit);
+
++    /**
++     * @brief Get the Tx Power Limit for 15.4
++     *
++     * @param &txPowerLimit
++     * will contain the value set in IWx12
++     * (txPowerLimit = 0.5dBm step, TX power back off : 0.5dBm step )
++     *
++     * @return otError
++     */
++    otError GetTxPowerLimit(uint8_t &txPowerLimit);
++
+     /**
+      * @brief GetMfgChannel
+      * @param channel
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index 0668213fd..5c4b5a85c 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -1225,12 +1225,19 @@ template <typename InterfaceType, typename ProcessContextType>
+ otError RadioSpinel<InterfaceType, ProcessContextType>::SetTxPowerLimit(uint8_t txPowerLimit)
+ {
+     otError error;
+-    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, txPowerLimit));
++    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_GET_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, txPowerLimit));
+
+ exit:
+     return error;
+ }
+
++template <typename InterfaceType, typename ProcessContextType>
++otError RadioSpinel<InterfaceType, ProcessContextType>::GetTxPowerLimit(uint8_t &txPowerLimit)
++{
++    otError error = Get(SPINEL_PROP_VENDOR_NXP_GET_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, &txPowerLimit);
++    return error;
++}
++
+ #define MAXBUFFERSIZE 16
+
+ template <typename InterfaceType, typename ProcessContextType>
+diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
+index cf1a4d56b..d31e109d3 100644
+--- a/src/lib/spinel/spinel.h
++++ b/src/lib/spinel/spinel.h
+@@ -4770,7 +4770,7 @@ enum
+     SPINEL_PROP_VENDOR_NXP_IR_CONFIG     = (SPINEL_PROP_VENDOR__BEGIN + 0x100),
+     SPINEL_PROP_VENDOR_NXP_IR_CMD        = (SPINEL_PROP_VENDOR__BEGIN + 0x101),
+     SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10A),
+-    SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10B),
++    SPINEL_PROP_VENDOR_NXP_GET_SET_TXPOWERLIMIT_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10B),
+     SPINEL_CMD_VENDOR_NXP_MFG  = (SPINEL_CMD_VENDOR__BEGIN + 0x3FF),
+
+     SPINEL_PROP_VENDOR__END   = 0x4000,
+diff --git a/src/posix/main.c b/src/posix/main.c
+index ed7cd99db..8120ced5d 100644
+--- a/src/posix/main.c
++++ b/src/posix/main.c
+@@ -458,13 +458,15 @@ static void ProcessSetEui64(void *aContext, uint8_t aArgsLength, char *aArgs[])
+     }
+ }
+
+-static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aArgs[])
++static void ProcessGetSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aArgs[])
+ {
++
++    uint8_t txPowerLimit = 0;
+     syslog(LOG_INFO, "SetTxPowerLimit");
+
+-    if( aArgsLength == 1 )
++    if( aArgsLength == 1 ) // set tx power limit
+     {
+-        uint8_t txPowerLimit = (uint8_t)atoi(aArgs[0]);
++        txPowerLimit = (uint8_t)atoi(aArgs[0]);
+         if((txPowerLimit>=1)&&(txPowerLimit<=44)){
+             syslog(LOG_INFO, "-> txPowerLimit : %d", txPowerLimit);
+         }else{
+@@ -473,6 +475,16 @@ static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aA
+         otPlatRadioSetTxPowerLimit(aContext, txPowerLimit);
+         syslog(LOG_INFO, "SetTxPowerLimit DONE");
+     }
++    else if ( aArgsLength == 0 ) // get tx power limit
++    {
++        otPlatRadioGetTxPowerLimit(aContext, &txPowerLimit);
++
++        // Add value in syslog
++        syslog(LOG_INFO, "TX power Value value : %d", txPowerLimit);
++
++        // Print value as ot-cli output
++        otCliOutputFormat("%d\r\n", txPowerLimit);
++    }
+     else
+     {
+         syslog(LOG_INFO, "SetTxPowerLimit FAILED! Invalid input arg");
+@@ -749,7 +761,7 @@ static const otCliCommand kCommands[] = {
+     {"ircfg", ProcessIRConfig},    //=> OutOfBand Independent Reset Configuration ircfg <1> means OOB mode
+     {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
+     {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
+-    {"txpwrlimit", ProcessSetTxPowerLimit}, //=> Set TX power limit for 15.4
++    {"txpwrlimit", ProcessGetSetTxPowerLimit}, //=> Set TX power limit for 15.4
+     {"mfgcmd", ProcessMfgCommands} //=> Generic VSC for MFG RF commands
+ };
+
+diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
+index 7f84d3ffc..ecc21e766 100644
+--- a/src/posix/platform/radio.cpp
++++ b/src/posix/platform/radio.cpp
+@@ -691,6 +691,12 @@ otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit)
+     return sRadioSpinel.SetTxPowerLimit(txPowerLimit);
+ }
+
++otError otPlatRadioGetTxPowerLimit(otInstance *aInstance, uint8_t* txPowerLimit)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    return sRadioSpinel.GetTxPowerLimit(*txPowerLimit);
++}
++
+ otError otPlatRadioMfgCommand(otInstance *aInstance, uint8_t *payload, const uint8_t payloadLenIn, uint8_t *payloadLenOut)
+ {
+     OT_UNUSED_VARIABLE(aInstance);
diff --git a/recipes-openthread/openthread/openthread.bb b/recipes-openthread/openthread/openthread.bb
index ad7d5e7..573111b 100644
--- a/recipes-openthread/openthread/openthread.bb
+++ b/recipes-openthread/openthread/openthread.bb
@@ -1,4 +1,5 @@
 PN = "openthread"
+PR = "r0"
 SUMMARY = "OTBR on i.MX boards"
 DESCRIPTION = "OTBR applications"
 LICENSE = "BSD-3-Clause"
@@ -6,7 +7,18 @@ LIC_FILES_CHKSUM = "file://LICENSE;md5=543b6fe90ec5901a683320a36390c65f"
 
 SRC_URI = "gitsm://github.com/openthread/openthread.git;branch=main;protocol=https"
 
-SRCREV = "2ce3d3bf0218566484be2e9943b95c755cefebe3"
+#SRCREV = "2ce3d3bf0218566484be2e9943b95c755cefebe3"
+SRCREV = "481a064f034496d93273f4b837d46559f7b74e5c"
+
+SRC_URI += "file://0001-coex-buff-issue-fix.patch"
+SRC_URI += "file://0002-csl-debug_prints.patch"
+SRC_URI += "file://0003-set-vsc-ir-eui64.patch"
+SRC_URI += "file://0004-set-vsc-txpwr-limit.patch"
+SRC_URI += "file://0005-host-spi-clear-tx-buffer.patch"
+SRC_URI += "file://0006-ot-daemon-release-resources.patch"
+SRC_URI += "file://0008-add-mfg-cmd-for-pfw.patch"
+SRC_URI += "file://0010-tcp-connection-war.patch"
+SRC_URI += "file://0011-get-vsc-txpwr-limit.patch"
 
 S = "${WORKDIR}/git"
 #FILES_${PN} += "lib/systemd"
@@ -28,7 +40,59 @@ def get_rcp_bus(d):
     return ''
 
 inherit cmake
-EXTRA_OECMAKE = "-GNinja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DOT_COMPILE_WARNING_AS_ERROR=OFF -DOT_PLATFORM=posix -DOT_SLAAC=ON -DOT_BORDER_AGENT=ON -DOT_BORDER_ROUTER=ON -DOT_COAP=ON -DOT_COAP_BLOCK=ON -DOT_COAP_OBSERVE=ON -DOT_COAPS=ON -DOT_COMMISSIONER=ON -DOT_CHANNEL_MANAGER=ON -DOT_CHANNEL_MONITOR=ON -DOT_CHILD_SUPERVISION=ON -DOT_DATASET_UPDATER=ON -DOT_DHCP6_CLIENT=ON -DOT_DHCP6_SERVER=ON -DOT_DIAGNOSTIC=ON -DOT_DNS_CLIENT=ON -DOT_ECDSA=ON -DOT_IP6_FRAGM=ON -DOT_JAM_DETECTION=ON -DOT_JOINER=ON -DOT_LEGACY=ON -DOT_MAC_FILTER=ON -DOT_MTD_NETDIAG=ON -DOT_NEIGHBOR_DISCOVERY_AGENT=ON -DOT_PING_SENDER=ON -DOT_REFERENCE_DEVICE=ON -DOT_SERVICE=ON -DOT_SNTP_CLIENT=ON -DOT_SRP_CLIENT=ON -DOT_COVERAGE=OFF -DOT_LOG_LEVEL_DYNAMIC=ON -DOT_RCP_RESTORATION_MAX_COUNT=2 -DOT_LOG_OUTPUT=PLATFORM_DEFINED -DOT_POSIX_MAX_POWER_TABLE=ON -DOT_DAEMON=ON -DOT_THREAD_VERSION=1.3 -DCMAKE_BUILD_TYPE=Release"
+
+EXTRA_OECMAKE = "-GNinja -DCMAKE_EXPORT_COMPILE_COMMANDS=ON -DOT_COMPILE_WARNING_AS_ERROR=OFF -DOT_PLATFORM=posix"
+EXTRA_OECMAKE += "-DOT_POSIX_MAX_POWER_TABLE=ON"
+EXTRA_OECMAKE += "-DOT_ANYCAST_LOCATOR=ON"
+EXTRA_OECMAKE += "-DOT_BACKBONE_ROUTER=ON"
+EXTRA_OECMAKE += "-DOT_BORDER_AGENT=ON"
+EXTRA_OECMAKE += "-DOT_BORDER_ROUTER=ON"
+EXTRA_OECMAKE += "-DOT_COAP=ON"
+EXTRA_OECMAKE += "-DOT_COAP_BLOCK=ON"
+EXTRA_OECMAKE += "-DOT_COAP_OBSERVE=ON"
+EXTRA_OECMAKE += "-DOT_COAP_SECURE=ON"
+EXTRA_OECMAKE += "-DOT_COAPS=ON"
+EXTRA_OECMAKE += "-DOT_COMMISSIONER=ON"
+EXTRA_OECMAKE += "-DOT_COVERAGE=OFF"
+EXTRA_OECMAKE += "-DOT_CHANNEL_MANAGER=ON"
+EXTRA_OECMAKE += "-DOT_CHANNEL_MONITOR=ON"
+EXTRA_OECMAKE += "-DOT_CHILD_SUPERVISION=ON"
+EXTRA_OECMAKE += "-DOT_DAEMON=ON"
+EXTRA_OECMAKE += "-DOT_DATASET_UPDATER=ON"
+EXTRA_OECMAKE += "-DOT_DHCP6_CLIENT=ON"
+EXTRA_OECMAKE += "-DOT_DHCP6_SERVER=ON"
+EXTRA_OECMAKE += "-DOT_DIAGNOSTIC=ON"
+EXTRA_OECMAKE += "-DOT_DNS_CLIENT=ON"
+EXTRA_OECMAKE += "-DOT_DNSSD_SERVER=ON"
+EXTRA_OECMAKE += "-DOT_DUA=ON"
+EXTRA_OECMAKE += "-DOT_ECDSA=ON"
+EXTRA_OECMAKE += "-DOT_FULL_LOGS=ON"
+EXTRA_OECMAKE += "-DOT_HISTORY_TRACKER=ON"
+EXTRA_OECMAKE += "-DOT_IP6_FRAGM=ON"
+EXTRA_OECMAKE += "-DOT_JAM_DETECTION=ON"
+EXTRA_OECMAKE += "-DOT_JOINER=ON"
+EXTRA_OECMAKE += "-DOT_LEGACY=ON"
+EXTRA_OECMAKE += "-DOT_LINK_METRICS_INITIATOR=ON"
+EXTRA_OECMAKE += "-DOT_LINK_METRICS_SUBJECT=ON"
+EXTRA_OECMAKE += "-DOT_LOG_LEVEL_DYNAMIC=ON"
+EXTRA_OECMAKE += "-DOT_LOG_OUTPUT=PLATFORM_DEFINED"
+EXTRA_OECMAKE += "-DOT_LOG_LOG_PREPEND_LEVEL=1"
+EXTRA_OECMAKE += "-DOT_MAC_FILTER=ON"
+EXTRA_OECMAKE += "-DOT_MLR=ON"
+EXTRA_OECMAKE += "-DOT_MTD_NETDIAG=ON"
+EXTRA_OECMAKE += "-DOT_NEIGHBOR_DISCOVERY_AGENT=ON"
+EXTRA_OECMAKE += "-DOT_NETDATA_PUBLISHER=ON"
+EXTRA_OECMAKE += "-DOT_PING_SENDER=ON"
+EXTRA_OECMAKE += "-DOT_RCP_RESTORATION_MAX_COUNT=10"
+EXTRA_OECMAKE += "-DOT_REFERENCE_DEVICE=ON"
+EXTRA_OECMAKE += "-DOT_SERVICE=ON"
+EXTRA_OECMAKE += "-DOT_SLAAC=ON"
+EXTRA_OECMAKE += "-DOT_SNTP_CLIENT=ON"
+EXTRA_OECMAKE += "-DOT_SRP_CLIENT=ON"
+EXTRA_OECMAKE += "-DOT_SRP_SERVER=ON"
+EXTRA_OECMAKE += "-DOT_THREAD_VERSION=1.3"
+EXTRA_OECMAKE += "-DOT_UPTIME=ON"
+EXTRA_OECMAKE += "-DCMAKE_BUILD_TYPE=Release"
 EXTRA_OECMAKE += "${@get_rcp_bus(d)}"
 
 do_install() {
-- 
2.25.1

