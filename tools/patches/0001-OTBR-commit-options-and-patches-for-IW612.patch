From 3d9156edd2df1070efc6cef7caa8f0aad509a747 Mon Sep 17 00:00:00 2001
From: nxf87843 <jean-yves.salaun@nxp.com>
Date: Thu, 15 Dec 2022 17:08:23 +0100
Subject: [PATCH] OTBR: commit options and patches for IW612

Signed-off-by: nxf87843 <jean-yves.salaun@nxp.com>
---
 ...t-options-and-otbr-firewall-for-IW61.patch |  94 ++++
 .../0001-coex-buff-issue-fix.patch            |  13 +
 .../0002-csl-debug_prints.patch               |  45 ++
 .../0003-set-vsc-ir-eui64.patch               | 245 ++++++++++
 .../0004-set-vsc-txpwr-limit.patch            | 130 ++++++
 .../0005-host-spi-clear-tx-buffer.patch       |  19 +
 .../0006-ot-daemon-release-resources.patch    |  43 ++
 .../0008-add-mfg-cmd-for-pfw.patch            | 420 ++++++++++++++++++
 .../0010-tcp-connection-war.patch             |  40 ++
 .../0011-get-vsc-txpwr-limit.patch            | 142 ++++++
 recipes-otbr/otbr/otbr.bb                     |  95 +++-
 11 files changed, 1280 insertions(+), 6 deletions(-)
 create mode 100644 recipes-otbr/otbr/files/0001-Update-otbr-agent-options-and-otbr-firewall-for-IW61.patch
 create mode 100644 recipes-otbr/otbr/files/openthread_patches/0001-coex-buff-issue-fix.patch
 create mode 100644 recipes-otbr/otbr/files/openthread_patches/0002-csl-debug_prints.patch
 create mode 100644 recipes-otbr/otbr/files/openthread_patches/0003-set-vsc-ir-eui64.patch
 create mode 100644 recipes-otbr/otbr/files/openthread_patches/0004-set-vsc-txpwr-limit.patch
 create mode 100644 recipes-otbr/otbr/files/openthread_patches/0005-host-spi-clear-tx-buffer.patch
 create mode 100644 recipes-otbr/otbr/files/openthread_patches/0006-ot-daemon-release-resources.patch
 create mode 100644 recipes-otbr/otbr/files/openthread_patches/0008-add-mfg-cmd-for-pfw.patch
 create mode 100644 recipes-otbr/otbr/files/openthread_patches/0010-tcp-connection-war.patch
 create mode 100644 recipes-otbr/otbr/files/openthread_patches/0011-get-vsc-txpwr-limit.patch

diff --git a/recipes-otbr/otbr/files/0001-Update-otbr-agent-options-and-otbr-firewall-for-IW61.patch b/recipes-otbr/otbr/files/0001-Update-otbr-agent-options-and-otbr-firewall-for-IW61.patch
new file mode 100644
index 0000000..ee739fd
--- /dev/null
+++ b/recipes-otbr/otbr/files/0001-Update-otbr-agent-options-and-otbr-firewall-for-IW61.patch
@@ -0,0 +1,94 @@
+From b59e9fbb35ce3342d416a493f361b6d03dffeb66 Mon Sep 17 00:00:00 2001
+From: nxf87843 <jean-yves.salaun@nxp.com>
+Date: Fri, 9 Dec 2022 14:10:56 +0100
+Subject: [PATCH 1/1] Update otbr-agent options and otbr-firewall for IW612
+ support
+
+Signed-off-by: nxf87843 <jean-yves.salaun@nxp.com>
+---
+ script/otbr-firewall            |  8 ++++--
+ script/otbr-firewall_README.txt | 44 +++++++++++++++++++++++++++++++++
+ src/agent/otbr-agent.default.in |  2 +-
+ 3 files changed, 50 insertions(+), 3 deletions(-)
+ create mode 100644 script/otbr-firewall_README.txt
+
+diff --git a/script/otbr-firewall b/script/otbr-firewall
+index 52cef42dd0..afbf20904e 100644
+--- a/script/otbr-firewall
++++ b/script/otbr-firewall
+@@ -41,8 +41,12 @@
+ THREAD_IF="wpan0"
+ OTBR_FORWARD_INGRESS_CHAIN="OTBR_FORWARD_INGRESS"
+ 
+-. /lib/lsb/init-functions
+-. /lib/init/vars.sh
++if [ -f /lib/lsb/init-functions ]; then
++ . /lib/lsb/init-functions
++fi
++if [ -f /lib/init/vars.sh ]; then
++ . /lib/init/vars.sh
++fi
+ 
+ set -euxo pipefail
+ 
+diff --git a/script/otbr-firewall_README.txt b/script/otbr-firewall_README.txt
+new file mode 100644
+index 0000000000..7347e8f2c6
+--- /dev/null
++++ b/script/otbr-firewall_README.txt
+@@ -0,0 +1,44 @@
++                         OTBR FIREWALL
++                         
++Installation:
++-------------
++
++1- copy all files on target, in:
++
++    /etc/init.d/otbr-firewall
++
++2- configure the target by running the following commands:
++
++It should be done only 1 time after flashing the IMX target, so first check the content of these files
++
++instructions comes from ot-br-posix/script/_ipforward: function ipforward_install().
++
++    echo "net.ipv6.conf.all.forwarding = 1" >  /etc/sysctl.d/60-otbr-ip-forward.conf
++    echo "net.ipv4.ip_forward = 1"          >> /etc/sysctl.d/60-otbr-ip-forward.conf
++
++instructions comes from ot-br-posix/script/_rt_tables: function rt_tables_install().
++
++    echo "88 openthread"                 >> /etc/iproute2/rt_tables
++
++    echo ""                              >> /etc/sysctl.conf
++    echo "# OpenThread configuration"    >> /etc/sysctl.conf
++    echo "net.core.optmem_max=65536"     >> /etc/sysctl.conf
++
++    sysctl -p /etc/sysctl.conf
++
++Execution:
++----------
++
++-for otbr-agent:
++
++    systemctl enable otbr-agent
++    systemctl start otbr-agent
++#To check if otbr is running    
++    systemctl status otbr-agent 
++
++-for otbr-firewall:
++
++   systemctl enable otbr-firewall
++    # => May show error, just ignore it since ot-br-posix does not provide otbr-firewall.service file
++    systemctl start otbr-firewall
++    systemctl status otbr-firewall
+diff --git a/src/agent/otbr-agent.default.in b/src/agent/otbr-agent.default.in
+index 049686f150..a21d297477 100644
+--- a/src/agent/otbr-agent.default.in
++++ b/src/agent/otbr-agent.default.in
+@@ -1,5 +1,5 @@
+ # Default settings for otbr-agent. This file is sourced by systemd
+ 
+ # Options to pass to otbr-agent
+-OTBR_AGENT_OPTS="-I wpan0 -B @OTBR_INFRA_IF_NAME@ spinel+hdlc+uart:///dev/ttyACM0 trel://@OTBR_INFRA_IF_NAME@"
++OTBR_AGENT_OPTS="-d 6 -I wpan0 -B @OTBR_INFRA_IF_NAME@ 'spinel+spi:///dev/spidev1.0?gpio-reset-device=/dev/gpiochip5&gpio-int-device=/dev/gpiochip5&gpio-int-line=12&gpio-reset-line=13&spi-mode=0&spi-speed=2000000&spi-reset-delay=0' trel://@OTBR_INFRA_IF_NAME@"
+ OTBR_NO_AUTO_ATTACH=@OTBR_NO_AUTO_ATTACH@
diff --git a/recipes-otbr/otbr/files/openthread_patches/0001-coex-buff-issue-fix.patch b/recipes-otbr/otbr/files/openthread_patches/0001-coex-buff-issue-fix.patch
new file mode 100644
index 0000000..f54e56d
--- /dev/null
+++ b/recipes-otbr/otbr/files/openthread_patches/0001-coex-buff-issue-fix.patch
@@ -0,0 +1,13 @@
+diff --git a/src/core/config/misc.h b/src/core/config/misc.h
+index 27a11e806..c1fae385f 100644
+--- a/src/core/config/misc.h
++++ b/src/core/config/misc.h
+@@ -156,7 +156,7 @@
+  *
+  */
+ #ifndef OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS
+-#define OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS 44
++#define OPENTHREAD_CONFIG_NUM_MESSAGE_BUFFERS 200
+ #endif
+ 
+ /**
diff --git a/recipes-otbr/otbr/files/openthread_patches/0002-csl-debug_prints.patch b/recipes-otbr/otbr/files/openthread_patches/0002-csl-debug_prints.patch
new file mode 100644
index 0000000..b45dba9
--- /dev/null
+++ b/recipes-otbr/otbr/files/openthread_patches/0002-csl-debug_prints.patch
@@ -0,0 +1,45 @@
+diff --git a/src/core/mac/mac.cpp b/src/core/mac/mac.cpp
+index 7e2f6503c..19ec01411 100644
+--- a/src/core/mac/mac.cpp
++++ b/src/core/mac/mac.cpp
+@@ -2272,9 +2272,12 @@ void Mac::ProcessCsl(const RxFrame &aFrame, const Address &aSrcAddr)
+     child->SetCslSynchronized(true);
+     child->SetCslLastHeard(TimerMilli::GetNow());
+     child->SetLastRxTimestamp(aFrame.GetTimestamp());
+-    LogDebg("Timestamp=%u Sequence=%u CslPeriod=%hu CslPhase=%hu TransmitPhase=%hu",
+-            static_cast<uint32_t>(aFrame.GetTimestamp()), aFrame.GetSequence(), csl->GetPeriod(), csl->GetPhase(),
+-            child->GetCslPhase());
++//    LogDebg("Timestamp=%u Sequence=%u CslPeriod=%hu CslPhase=%hu TransmitPhase=%hu",
++//            static_cast<uint32_t>(aFrame.GetTimestamp()), aFrame.GetSequence(), csl->GetPeriod(), csl->GetPhase(),
++//            child->GetCslPhase());
++    LogDebg("Timestamp=%llu Sequence=%u CslPeriod=%hu CslPhase=%hu TransmitPhase=%hu",
++                 aFrame.GetTimestamp(), aFrame.GetSequence(), csl->GetPeriod(), csl->GetPhase(),
++                  child->GetCslPhase());
+ 
+     Get<CslTxScheduler>().Update();
+ 
+diff --git a/src/core/thread/csl_tx_scheduler.cpp b/src/core/thread/csl_tx_scheduler.cpp
+index 15beb59b9..2094f3f42 100644
+--- a/src/core/thread/csl_tx_scheduler.cpp
++++ b/src/core/thread/csl_tx_scheduler.cpp
+@@ -162,6 +162,8 @@ uint32_t CslTxScheduler::GetNextCslTransmissionDelay(const Child &aChild, uint32
+ 
+     aDelayFromLastRx = static_cast<uint32_t>(nextTxWindow - aChild.GetLastRxTimestamp());
+ 
++    otLogInfoPlat("CSL radioNow = %llu, periodInUS = %hu,firstTXWindow = %llu, nextTxWindow = %llu, aDelayFromLastRx = %u, lastRxTimeStamp = %llu", radioNow, periodInUs, firstTxWindow, nextTxWindow, aDelayFromLastRx,aChild.GetLastRxTimestamp());
++
+     return static_cast<uint32_t>(nextTxWindow - radioNow - mCslFrameRequestAheadUs);
+ }
+ 
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index c6c02e288..000f59555 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -2204,6 +2204,7 @@ exit:
+ template <typename InterfaceType, typename ProcessContextType>
+ uint64_t RadioSpinel<InterfaceType, ProcessContextType>::GetNow(void)
+ {
++    otLogDebgPlat("mIsTimeSynced = %d, otPlatTimeGet = %llu, mRadioTimeOffset = %u",mIsTimeSynced, otPlatTimeGet(), mRadioTimeOffset);
+     return mIsTimeSynced ? (otPlatTimeGet() + static_cast<uint64_t>(mRadioTimeOffset)) : UINT64_MAX;
+ }
+ 
diff --git a/recipes-otbr/otbr/files/openthread_patches/0003-set-vsc-ir-eui64.patch b/recipes-otbr/otbr/files/openthread_patches/0003-set-vsc-ir-eui64.patch
new file mode 100644
index 0000000..a0b265c
--- /dev/null
+++ b/recipes-otbr/otbr/files/openthread_patches/0003-set-vsc-ir-eui64.patch
@@ -0,0 +1,245 @@
+From 3d8788a3faba54b269717cb12267b338143054d1 Mon Sep 17 00:00:00 2001
+From: Sylvain Potel <sylvain.potel@nxp.com>
+Date: Thu, 19 May 2022 11:56:37 +0200
+Subject: Issue WSW-19369 Add API to Set IEEE.802.15.4 MAC Address if RCP does
+ not provide persistent storage (seteui64). Add APIs to configure and set
+ Independent Reset in ot-ctl as well.
+
+
+diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
+index 2d7a654b9..521513811 100644
+--- a/include/openthread/platform/radio.h
++++ b/include/openthread/platform/radio.h
+@@ -1144,11 +1144,19 @@ otError otPlatRadioConfigureEnhAckProbing(otInstance *        aInstance,
+  * @}
+  *
+  */
++void otPlatRadioSetIRCmd(otInstance *aInstance);
+ 
+ /**
+  * @}
+  *
+  */
++void otPlatRadioSetIRConfig(otInstance *aInstance, uint8_t mode);
++
++/**
++ * @}
++ *
++ */
++otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeeeEui64);
+ 
+ #ifdef __cplusplus
+ } // end of extern "C"
+diff --git a/src/lib/spinel/radio_spinel.hpp b/src/lib/spinel/radio_spinel.hpp
+index 7953a2b8d..ab12766cd 100644
+--- a/src/lib/spinel/radio_spinel.hpp
++++ b/src/lib/spinel/radio_spinel.hpp
+@@ -174,6 +174,18 @@ public:
+      */
+     otError GetIeeeEui64(uint8_t *aIeeeEui64);
+ 
++    /**
++     * This method sets the factory-assigned IEEE EUI-64 for this transceiver.
++     *
++     * @param[in]  aInstance   The OpenThread instance structure.
++     * @param[out] aIeeeEui64  A pointer to the factory-assigned IEEE EUI-64.
++     *
++     * @retval  OT_ERROR_NONE               Succeeded.
++     * @retval  OT_ERROR_INVALID_STATE      Failed EUI64 is set by factory only except if OTP is not supported.
++     * 
++     */
++    otError SetIeeeEui64(const otExtAddress &aIeeeEui64);
++
+     /**
+      * This method sets the Extended Address for address filtering.
+      *
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index 9faf91548..744d05b77 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -1204,6 +1204,23 @@ otError RadioSpinel<InterfaceType, ProcessContextType>::GetIeeeEui64(uint8_t *aI
+     return OT_ERROR_NONE;
+ }
+ 
++template <typename InterfaceType, typename ProcessContextType>
++otError RadioSpinel<InterfaceType, ProcessContextType>::SetIeeeEui64(const otExtAddress &aIeeeEui64)
++{
++    otExtAddress addr;
++    otError      error;
++
++    for (size_t i = 0; i < sizeof(addr); i++)
++    {
++        addr.m8[i] = aIeeeEui64.m8[sizeof(addr) - 1 - i];
++    }
++
++    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD, SPINEL_DATATYPE_EUI64_S, addr.m8));
++    mIeeeEui64 = aIeeeEui64;
++exit:
++    return error;
++}
++
+ template <typename InterfaceType, typename ProcessContextType>
+ otError RadioSpinel<InterfaceType, ProcessContextType>::SetExtendedAddress(const otExtAddress &aExtAddress)
+ {
+diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
+index 8b6db66fa..12187031e 100644
+--- a/src/lib/spinel/spinel.h
++++ b/src/lib/spinel/spinel.h
+@@ -4748,6 +4748,11 @@ enum
+     SPINEL_PROP_NEST__END = 0x3C00,
+ 
+     SPINEL_PROP_VENDOR__BEGIN = 0x3C00,
++
++    SPINEL_PROP_VENDOR_NXP_IR_CONFIG     = (SPINEL_PROP_VENDOR__BEGIN + 0x100),
++    SPINEL_PROP_VENDOR_NXP_IR_CMD        = (SPINEL_PROP_VENDOR__BEGIN + 0x101),
++    SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10A),
++
+     SPINEL_PROP_VENDOR__END   = 0x4000,
+ 
+     SPINEL_PROP_VENDOR_ESP__BEGIN = (SPINEL_PROP_VENDOR__BEGIN + 0),
+diff --git a/src/posix/main.c b/src/posix/main.c
+index ebecb4777..08d4dc5ac 100644
+--- a/src/posix/main.c
++++ b/src/posix/main.c
+@@ -352,11 +352,108 @@ static void ProcessExit(void *aContext, uint8_t aArgsLength, char *aArgs[])
+ }
+ #endif
+ 
++// 15.4_INDEPENDENT_RESET
++static void ProcessIRConfig(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    syslog(LOG_INFO, "ProcessIRConfig");
++
++    if( aArgsLength == 1 )
++    {
++        uint16_t mode = (uint16_t)atoi(aArgs[0]);
++        syslog(LOG_INFO, "-> mode %s", mode==0 ? "Disable IR":(mode==1 ?("OOB IR"):"InBand IR"));
++        if( mode < 3 )
++        {
++            otPlatRadioSetIRConfig(aContext, mode);
++            syslog(LOG_INFO, "ProcessIRConfig DONE");
++        }
++    }
++    else
++    {
++        syslog(LOG_INFO, "ProcessIRConfig FAILED!");
++    }
++}
++
++static void ProcessIRCmd(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    OT_UNUSED_VARIABLE(aArgsLength);
++    OT_UNUSED_VARIABLE(aArgs);
++    syslog(LOG_INFO, "ProcessIRCmd");
++    otPlatRadioSetIRCmd(aContext);
++    syslog(LOG_INFO, "ProcessIRCmd DONE");
++}
++
++static void ProcessSetEui64(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    if( aArgsLength == 1 )
++    {
++        otExtAddress addr;
++        char        *hex  = *aArgs;
++
++        syslog(LOG_INFO, "+ SetEui64 %s (len %d)", *aArgs, (uint32_t)strlen(*aArgs));
++
++        if( (hex[1] == 'x') && (strlen(*aArgs) == 18) )
++        {
++            otError error = OT_ERROR_NONE;
++
++            hex = hex + 2;
++
++            for(uint32_t i = 0; (i < 8) && (error == OT_ERROR_NONE); i++)
++            {
++                addr.m8[i] = 0;
++                for(uint32_t k = 0; k < 2; k++)
++                {
++                    // get current character then increment
++                    uint8_t byte = *hex++;
++                    // transform hex character to the 4bit equivalent number, using the ascii table indexes
++                    if (byte >= '0' && byte <= '9')
++                        byte = byte - '0';
++                    else if (byte >= 'a' && byte <='f')
++                        byte = byte - 'a' + 10;
++                    else if (byte >= 'A' && byte <='F')
++                        byte = byte - 'A' + 10;
++                    else
++                    {
++                        error = OT_ERROR_FAILED;
++                        break;
++                    }
++                    // shift 4 to make space for new digit, and add the 4 bits of the new digit
++                    addr.m8[i] = (addr.m8[i] << 4) | (byte & 0xF);
++                }
++            }
++
++            if( error == OT_ERROR_NONE )
++            {
++                error = otPlatRadioSetIeeeEui64(aContext, (const otExtAddress*)&addr);
++            }
++
++            if( error != OT_ERROR_NONE )
++            {
++                syslog(LOG_INFO, "- SetEui64 Failed (%#x)", error);
++            }
++            else
++            {
++                syslog(LOG_INFO, "- SetEui64 SUCCESS");
++            }
++        }
++        else
++        {
++            syslog(LOG_INFO, "- SetEui64 invalid input arg (0x....?) !");
++        }
++    }
++    else
++    {
++        syslog(LOG_INFO, "- SetEui64 FAILED !");
++    }
++}
++
+ static const otCliCommand kCommands[] = {
+ #if !OPENTHREAD_POSIX_CONFIG_DAEMON_ENABLE
+     {"exit", ProcessExit},
+ #endif
+     {"netif", ProcessNetif},
++    {"ircfg", ProcessIRConfig},    //=> OutOfBand Independent Reset Configuration ircfg <1> means OOB mode
++    {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
++    {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
+ };
+ 
+ int main(int argc, char *argv[])
+diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
+index 410975272..db5cadda9 100644
+--- a/src/posix/platform/radio.cpp
++++ b/src/posix/platform/radio.cpp
+@@ -639,3 +639,27 @@ otError otPlatRadioReceiveAt(otInstance *aInstance, uint8_t aChannel, uint32_t a
+     OT_UNUSED_VARIABLE(aDuration);
+     return OT_ERROR_NOT_IMPLEMENTED;
+ }
++
++void otPlatRadioSetIRConfig(otInstance *aInstance, uint8_t mode)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    SuccessOrDie(sRadioSpinel.Set(SPINEL_PROP_VENDOR_NXP_IR_CONFIG, SPINEL_DATATYPE_UINT16_S, mode));
++}
++void otPlatRadioSetIRCmd(otInstance *aInstance)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    SuccessOrDie(sRadioSpinel.Set(SPINEL_PROP_VENDOR_NXP_IR_CMD, SPINEL_DATATYPE_UINT16_S));
++}
++
++otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeeeEui64)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    otExtAddress addr;
++
++    for (size_t i = 0; i < sizeof(addr); i++)
++    {
++        addr.m8[i] = aIeeeEui64->m8[sizeof(addr) - 1 - i];
++    }
++
++    return sRadioSpinel.SetIeeeEui64(*aIeeeEui64);
++}
+\ No newline at end of file
diff --git a/recipes-otbr/otbr/files/openthread_patches/0004-set-vsc-txpwr-limit.patch b/recipes-otbr/otbr/files/openthread_patches/0004-set-vsc-txpwr-limit.patch
new file mode 100644
index 0000000..a446db2
--- /dev/null
+++ b/recipes-otbr/otbr/files/openthread_patches/0004-set-vsc-txpwr-limit.patch
@@ -0,0 +1,130 @@
+diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
+index 2a1252c04..ba61d1373 100644
+--- a/include/openthread/platform/radio.h
++++ b/include/openthread/platform/radio.h
+@@ -1158,6 +1158,12 @@ void otPlatRadioSetIRConfig(otInstance *aInstance, uint8_t mode);
+  */
+ otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeeeEui64);
+ 
++/**
++ * @}
++ *
++ */
++otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit);
++
+ #ifdef __cplusplus
+ } // end of extern "C"
+ #endif
+diff --git a/src/lib/spinel/radio_spinel.hpp b/src/lib/spinel/radio_spinel.hpp
+index 23810a9ef..1605e5cd3 100644
+--- a/src/lib/spinel/radio_spinel.hpp
++++ b/src/lib/spinel/radio_spinel.hpp
+@@ -186,6 +186,18 @@ public:
+      */
+     otError SetIeeeEui64(const otExtAddress &aIeeeEui64);
+ 
++    /**
++     * @brief Set the Tx Power Limit for 15.4
++     *
++     * @param txPowerLimit
++     * txPowerLimit (0 or higher than 22), No power backoff is applied
++     * txPowerLimit = 1 to 44, force TX power back off to txPowerLimit
++     * (txPowerLimit = 0.5dBm step, TX power back off : 0.5dBm step )
++     *
++     * @return otError
++     */
++    otError SetTxPowerLimit(uint8_t txPowerLimit);
++
+     /**
+      * This method sets the Extended Address for address filtering.
+      *
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index 4448e0e93..c0b950e01 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -1221,6 +1221,16 @@ exit:
+     return error;
+ }
+ 
++template <typename InterfaceType, typename ProcessContextType>
++otError RadioSpinel<InterfaceType, ProcessContextType>::SetTxPowerLimit(uint8_t txPowerLimit)
++{
++    otError error;
++    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, txPowerLimit));
++
++exit:
++    return error;
++}
++
+ template <typename InterfaceType, typename ProcessContextType>
+ otError RadioSpinel<InterfaceType, ProcessContextType>::SetExtendedAddress(const otExtAddress &aExtAddress)
+ {
+diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
+index 130698a7a..48004460b 100644
+--- a/src/lib/spinel/spinel.h
++++ b/src/lib/spinel/spinel.h
+@@ -4770,6 +4770,7 @@ enum
+     SPINEL_PROP_VENDOR_NXP_IR_CONFIG     = (SPINEL_PROP_VENDOR__BEGIN + 0x100),
+     SPINEL_PROP_VENDOR_NXP_IR_CMD        = (SPINEL_PROP_VENDOR__BEGIN + 0x101),
+     SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10A),
++    SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10B),
+ 
+     SPINEL_PROP_VENDOR__END   = 0x4000,
+ 
+diff --git a/src/posix/main.c b/src/posix/main.c
+index 7a12a59ac..317300b94 100644
+--- a/src/posix/main.c
++++ b/src/posix/main.c
+@@ -439,6 +439,27 @@ static void ProcessSetEui64(void *aContext, uint8_t aArgsLength, char *aArgs[])
+     }
+ }
+ 
++static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    syslog(LOG_INFO, "SetTxPowerLimit");
++
++    if( aArgsLength == 1 )
++    {
++        uint8_t txPowerLimit = (uint8_t)atoi(aArgs[0]);
++        if((txPowerLimit>=1)&&(txPowerLimit<=22)){
++            syslog(LOG_INFO, "-> txPowerLimit : %d", txPowerLimit);
++        }else{
++            syslog(LOG_INFO, "-> txPowerLimit : default value");
++        }
++        otPlatRadioSetTxPowerLimit(aContext, txPowerLimit);
++        syslog(LOG_INFO, "SetTxPowerLimit DONE");
++    }
++    else
++    {
++        syslog(LOG_INFO, "SetTxPowerLimit FAILED! Invalid input arg");
++    }
++}
++
+ static const otCliCommand kCommands[] = {
+ #if !OPENTHREAD_POSIX_CONFIG_DAEMON_ENABLE
+     {"exit", ProcessExit},
+@@ -447,6 +468,7 @@ static const otCliCommand kCommands[] = {
+     {"ircfg", ProcessIRConfig},    //=> OutOfBand Independent Reset Configuration ircfg <1> means OOB mode
+     {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
+     {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
++    {"txpwrlimit", ProcessSetTxPowerLimit}, //=> Set TX power limit for 15.4
+ };
+ 
+ int main(int argc, char *argv[])
+diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
+index d7c817483..d6cc7f6fe 100644
+--- a/src/posix/platform/radio.cpp
++++ b/src/posix/platform/radio.cpp
+@@ -683,4 +683,10 @@ otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeee
+     }
+ 
+     return sRadioSpinel.SetIeeeEui64(*aIeeeEui64);
+-}
+\ No newline at end of file
++}
++
++otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    return sRadioSpinel.SetTxPowerLimit(txPowerLimit);
++}
diff --git a/recipes-otbr/otbr/files/openthread_patches/0005-host-spi-clear-tx-buffer.patch b/recipes-otbr/otbr/files/openthread_patches/0005-host-spi-clear-tx-buffer.patch
new file mode 100644
index 0000000..02dc771
--- /dev/null
+++ b/recipes-otbr/otbr/files/openthread_patches/0005-host-spi-clear-tx-buffer.patch
@@ -0,0 +1,19 @@
+From 2ee6d02119bd9a89c0d122abd551d69df57868e7 Mon Sep 17 00:00:00 2001
+From: Guillaume Legoupil <guillaume.legoupil@nxp.com>
+Date: Mon, 4 Jul 2022 09:28:17 +0200
+Subject: Spi Host: clear tx buffer
+
+
+diff --git a/src/posix/platform/spi_interface.cpp b/src/posix/platform/spi_interface.cpp
+index 752dd44c1..e805b548c 100644
+--- a/src/posix/platform/spi_interface.cpp
++++ b/src/posix/platform/spi_interface.cpp
+@@ -598,6 +598,8 @@ otError SpiInterface::PushPullSpi(void)
+             mSpiTxFrameByteCount += mSpiTxPayloadSize;
+ 
+             mSpiTxIsReady      = false;
++            // Clear tx buffer after usage
++            memset(&mSpiTxFrameBuffer[kSpiFrameHeaderSize], 0, mSpiTxPayloadSize);
+             mSpiTxPayloadSize  = 0;
+             mSpiTxRefusedCount = 0;
+         }
diff --git a/recipes-otbr/otbr/files/openthread_patches/0006-ot-daemon-release-resources.patch b/recipes-otbr/otbr/files/openthread_patches/0006-ot-daemon-release-resources.patch
new file mode 100644
index 0000000..dbe04ab
--- /dev/null
+++ b/recipes-otbr/otbr/files/openthread_patches/0006-ot-daemon-release-resources.patch
@@ -0,0 +1,43 @@
+From ac5a4479f73619c6aad9ef06b1cc7711694db110 Mon Sep 17 00:00:00 2001
+From: Guillaume Legoupil <guillaume.legoupil@nxp.com>
+Date: Mon, 18 Jul 2022 11:48:02 +0200
+Subject: ot-daemon: release resources before leaving
+
+
+diff --git a/src/posix/platform/hdlc_interface.cpp b/src/posix/platform/hdlc_interface.cpp
+index 391fdacd5..6fce71867 100644
+--- a/src/posix/platform/hdlc_interface.cpp
++++ b/src/posix/platform/hdlc_interface.cpp
+@@ -182,6 +182,7 @@ HdlcInterface::~HdlcInterface(void)
+ 
+ void HdlcInterface::Deinit(void)
+ {
++    otLogDebgPlat("Deinit: close %s", (mSockFd >= 0)?("Radio "):(""));
+     CloseFile();
+ }
+ 
+diff --git a/src/posix/platform/spi_interface.cpp b/src/posix/platform/spi_interface.cpp
+index 752dd44c1..eb4a129e7 100644
+--- a/src/posix/platform/spi_interface.cpp
++++ b/src/posix/platform/spi_interface.cpp
+@@ -204,6 +204,7 @@ SpiInterface::~SpiInterface(void)
+ 
+ void SpiInterface::Deinit(void)
+ {
++    otLogDebgPlat("Deinit: close %s%s%s", (mSpiDevFd >= 0)?("SpiDev "):(""), (mResetGpioValueFd >= 0)?("ResetGpio "):(""), (mIntGpioValueFd >= 0)?("IntGpio "):(""));
+     if (mSpiDevFd >= 0)
+     {
+         close(mSpiDevFd);
+diff --git a/src/posix/platform/system.cpp b/src/posix/platform/system.cpp
+index c3e176abe..3cfb20d52 100644
+--- a/src/posix/platform/system.cpp
++++ b/src/posix/platform/system.cpp
+@@ -125,6 +125,8 @@ void platformInit(otPlatformConfig *aPlatformConfig)
+     platformAlarmInit(aPlatformConfig->mSpeedUpFactor, aPlatformConfig->mRealTimeSignal);
+     platformRadioInit(get802154RadioUrl(aPlatformConfig));
+ 
++    atexit(&platformRadioDeinit);
++
+     // For Dry-Run option, only init the radio.
+     VerifyOrExit(!aPlatformConfig->mDryRun);
+ 
diff --git a/recipes-otbr/otbr/files/openthread_patches/0008-add-mfg-cmd-for-pfw.patch b/recipes-otbr/otbr/files/openthread_patches/0008-add-mfg-cmd-for-pfw.patch
new file mode 100644
index 0000000..5be4227
--- /dev/null
+++ b/recipes-otbr/otbr/files/openthread_patches/0008-add-mfg-cmd-for-pfw.patch
@@ -0,0 +1,420 @@
+From 98c298926f14ec1d4ae29cde63280a127f42c0ba Mon Sep 17 00:00:00 2001
+From: Maele Philippot <maele.philippot@nxp.com>
+Date: Thu, 11 Aug 2022 11:28:55 +0200
+Subject: [PATCH 1/1] Issue: WSW-19668 [IW512] Add RF testing features support to PFW (only supported in MFG for now)
+Add MFG vendor specific command to enable RF testing using ot-ctl.
+
+---
+ include/openthread/platform/radio.h  |   6 +
+ src/lib/spinel/radio_spinel.hpp      |   7 +
+ src/lib/spinel/radio_spinel_impl.hpp |  15 ++
+ src/lib/spinel/spinel.h              |   1 +
+ src/posix/main.c                     | 284 ++++++++++++++++++++++++++-
+ src/posix/platform/radio.cpp         |   6 +
+ 6 files changed, 318 insertions(+), 1 deletion(-)
+
+diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
+index ba61d1373..c9c94e430 100644
+--- a/include/openthread/platform/radio.h
++++ b/include/openthread/platform/radio.h
+@@ -1164,6 +1164,12 @@ otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeee
+  */
+ otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit);
+ 
++/**
++ * @}
++ *
++ */
++otError otPlatRadioMfgCommand(otInstance *aInstance, uint8_t *payload, const uint8_t payloadLenIn, uint8_t *payloadLenOut);
++
+ #ifdef __cplusplus
+ } // end of extern "C"
+ #endif
+diff --git a/src/lib/spinel/radio_spinel.hpp b/src/lib/spinel/radio_spinel.hpp
+index 2505e524b..1664e2ff2 100644
+--- a/src/lib/spinel/radio_spinel.hpp
++++ b/src/lib/spinel/radio_spinel.hpp
+@@ -198,6 +198,13 @@ public:
+      */
+     otError SetTxPowerLimit(uint8_t txPowerLimit);
+ 
++    /**
++     * @brief GetMfgChannel
++     * @param channel
++     * @return otError
++     */
++    otError MfgCmd(uint8_t *payload, const uint8_t payloadLenIn, uint8_t &payloadLenOut);
++
+     /**
+      * This method sets the Extended Address for address filtering.
+      *
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index ce88ea8a0..32a4cc1f2 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -1231,6 +1231,21 @@ exit:
+     return error;
+ }
+ 
++#define MAXBUFFERSIZE 16
++
++template <typename InterfaceType, typename ProcessContextType>
++otError RadioSpinel<InterfaceType, ProcessContextType>::MfgCmd(uint8_t *payload, const uint8_t payloadLenIn, uint8_t &payloadLenOut)
++{
++    otError error;
++    uint8_t buffer[MAXBUFFERSIZE]; //temporary buffer used to be passed as arg of GetWithParam
++    spinel_ssize_t packed;
++
++    packed = spinel_datatype_pack(buffer, sizeof(buffer), SPINEL_DATATYPE_DATA_S, payload, payloadLenIn);
++    error = GetWithParam(SPINEL_CMD_VENDOR_NXP_MFG, buffer, static_cast<spinel_size_t>(packed), SPINEL_DATATYPE_DATA_S, payload, &payloadLenOut);
++
++    return error;
++}
++
+ template <typename InterfaceType, typename ProcessContextType>
+ otError RadioSpinel<InterfaceType, ProcessContextType>::SetExtendedAddress(const otExtAddress &aExtAddress)
+ {
+diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
+index aa738cfa2..cf1a4d56b 100644
+--- a/src/lib/spinel/spinel.h
++++ b/src/lib/spinel/spinel.h
+@@ -4771,6 +4771,7 @@ enum
+     SPINEL_PROP_VENDOR_NXP_IR_CMD        = (SPINEL_PROP_VENDOR__BEGIN + 0x101),
+     SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10A),
+     SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10B),
++    SPINEL_CMD_VENDOR_NXP_MFG  = (SPINEL_CMD_VENDOR__BEGIN + 0x3FF),
+ 
+     SPINEL_PROP_VENDOR__END   = 0x4000,
+ 
+diff --git a/src/posix/main.c b/src/posix/main.c
+index c8f9c589b..ed7cd99db 100644
+--- a/src/posix/main.c
++++ b/src/posix/main.c
+@@ -70,6 +70,25 @@
+ 
+ #include "lib/platform/reset_util.h"
+ 
++#define MFG_CMD_ACTION_GET 0
++#define MFG_CMD_ACTION_SET 1
++
++#define MFG_CMD_GET_SET_CHANNEL 0x0b      // 11
++#define MFG_CMD_GET_SET_TXPOWER 0x0f      // 15
++#define MFG_CMD_CONTINUOUS_TX 0x11        // 17
++#define MFG_CMD_GET_SET_PAYLOAD_SIZE 0x14 // 20
++#define MFG_CMD_GET_RX_RESULT 0x1f        // 31
++#define MFG_CMD_START_RX_TEST 0x20        // 32
++#define MFG_CMD_BURST_TX 0x21             // 33
++#define MFG_CMD_DUTY_CYCLE_TX 0x23        // 35
++#define MFG_CMD_GET_SET_CCA_THRESHOLD  0x2F   // 47
++#define MFG_CMD_CONTINOUS_CCA_TEST 0X31   //49
++#define MFG_CMD_GET_CCA_STATUS 0x32       //50
++#define MFG_CMD_CONTINOUS_ED_TEST 0x37    //55
++#define MFG_CMD_GET_ED_VALUE    0x38      //56
++
++uint8_t mfgEnable = 0;
++
+ /**
+  * This function initializes NCP app.
+  *
+@@ -446,7 +465,7 @@ static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aA
+     if( aArgsLength == 1 )
+     {
+         uint8_t txPowerLimit = (uint8_t)atoi(aArgs[0]);
+-        if((txPowerLimit>=1)&&(txPowerLimit<=22)){
++        if((txPowerLimit>=1)&&(txPowerLimit<=44)){
+             syslog(LOG_INFO, "-> txPowerLimit : %d", txPowerLimit);
+         }else{
+             syslog(LOG_INFO, "-> txPowerLimit : default value");
+@@ -460,6 +479,268 @@ static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aA
+     }
+ }
+ 
++static otError ProcessMfgGetInt8(void *aContext, uint8_t cmdId, uint8_t aArgsLength)
++{
++    otError error = OT_ERROR_INVALID_ARGS;
++    uint8_t outputLen = 0;
++    uint8_t payload[12] = {11};
++    uint8_t payloadLen = 12;
++
++    if(aArgsLength == 1)
++    {
++        payload[1] = cmdId;
++        payload[2] = MFG_CMD_ACTION_GET;
++
++        otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++
++        if((outputLen >= 5) && (payload[3] == 0))
++        {
++            otCliOutputFormat("%d\r\n", (int8_t)payload[4]);
++            error = OT_ERROR_NONE;
++        }
++        else{
++            error = OT_ERROR_FAILED;
++        }
++    }
++
++    return error;
++}
++
++static otError ProcessMfgSetInt8(void *aContext, uint8_t cmdId, uint8_t aArgsLength, char *aArgs[], int8_t min, int8_t max)
++{
++    otError error = OT_ERROR_INVALID_ARGS;
++    uint8_t outputLen = 0;
++    uint8_t payload[12] = {11};
++    uint8_t payloadLen = 12;
++    int8_t setValue = 0;
++
++    if(aArgsLength == 2)
++    {
++        setValue = (int8_t)atoi(aArgs[1]);
++        if((setValue >= min) && (setValue <= max))
++        {
++            payload[1] = cmdId;
++            payload[2] = MFG_CMD_ACTION_SET;
++            payload[4] = (uint8_t)setValue;
++
++            otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++
++            if((outputLen >= 4) && (payload[3] == 0))
++            {
++                error = OT_ERROR_NONE;
++            }
++            else
++            {
++                error = OT_ERROR_FAILED;
++            }
++        }
++    }
++
++    return error;
++}
++
++static void ProcessMfgCommands(void *aContext, uint8_t aArgsLength, char *aArgs[])
++{
++    uint8_t payload[12] = {11};
++    uint8_t payloadLen = 12;
++    uint8_t outputLen = 0;
++    otError error = OT_ERROR_INVALID_ARGS;
++    uint8_t cmdId, idx;
++
++    if(aArgsLength == 1)
++    {
++        cmdId = (uint8_t)atoi(aArgs[0]);
++        if((cmdId == 0)||(cmdId == 1))
++        {
++            mfgEnable = cmdId;
++            syslog(LOG_INFO, "MFG command SUCCESS");
++            return;
++        }
++    }
++
++    if(mfgEnable == 0)
++    {
++        syslog(LOG_INFO, "MFG command not enabled");
++        otCliOutputFormat("MFG command not enabled. to enable it : mfgcmd 1\r\n");
++        return;
++    }
++
++    if ((aArgsLength > 0) && (mfgEnable == 1))
++    {
++        cmdId = (uint8_t)atoi(aArgs[0]);
++
++        switch (cmdId)
++        {
++        case MFG_CMD_GET_SET_CHANNEL: // get channel
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_SET_CHANNEL, aArgsLength);
++            break;
++
++        case MFG_CMD_GET_SET_CHANNEL + 1: // set channel
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_GET_SET_CHANNEL, aArgsLength, aArgs, 11, 26);
++            break;
++
++        case MFG_CMD_GET_SET_TXPOWER: // get txpower
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_SET_TXPOWER, aArgsLength);
++            break;
++
++        case MFG_CMD_GET_SET_TXPOWER + 1: // set txpower
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_GET_SET_TXPOWER, aArgsLength, aArgs, -40, 44);
++            break;
++
++        case MFG_CMD_CONTINUOUS_TX:
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_CONTINUOUS_TX, aArgsLength, aArgs, 0, 1);
++            break;
++
++        case MFG_CMD_GET_SET_PAYLOAD_SIZE: // get
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_SET_PAYLOAD_SIZE, aArgsLength);
++            break;
++
++        case MFG_CMD_GET_SET_PAYLOAD_SIZE + 1: // set
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_GET_SET_PAYLOAD_SIZE, aArgsLength, aArgs, 0, 127);
++            // actual limits are set in MFG function and error is return in case of wrong parameter
++            break;
++
++        case MFG_CMD_GET_RX_RESULT:
++        {
++            if(aArgsLength == 1)
++            {
++                payload[1] = MFG_CMD_GET_RX_RESULT;
++                payload[2] = MFG_CMD_ACTION_GET;
++                otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++                if(outputLen >= 11)
++                {
++                    otCliOutputFormat("status : %d\r\n", payload[4]);
++                    otCliOutputFormat("rx_pkt_count : %d\r\n", payload[5]|(payload[6]<<8));
++                    otCliOutputFormat("total_pkt_count : %d\r\n", payload[7]|(payload[8]<<8));
++                    otCliOutputFormat("rssi : %d\r\n",(int8_t)payload[9]);
++                    otCliOutputFormat("lqi : %d\r\n", payload[10]);
++                    error = OT_ERROR_NONE;
++                }
++                else{
++                    error = OT_ERROR_FAILED;
++                }
++            }
++        }
++        break;
++
++        case MFG_CMD_START_RX_TEST:
++        {
++            if(aArgsLength == 1)
++            {
++                payload[1] = MFG_CMD_START_RX_TEST;
++                otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++                error = OT_ERROR_NONE;
++            }
++        }
++        break;
++
++        case MFG_CMD_BURST_TX:
++        {
++            uint8_t mode = 0;
++            if(aArgsLength == 3)
++            {
++                mode = (uint8_t)atoi(aArgs[1]);
++                if(mode < 8)
++                {
++                    payload[1] = MFG_CMD_BURST_TX;
++                    payload[4] = mode;
++                    payload[5] = (uint8_t)atoi(aArgs[2]);
++                    otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++                    error = OT_ERROR_NONE;
++                }
++            }
++        }
++        break;
++
++        case MFG_CMD_DUTY_CYCLE_TX:
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_DUTY_CYCLE_TX, aArgsLength, aArgs, 0, 1);
++            break;
++
++        case MFG_CMD_GET_SET_CCA_THRESHOLD: // get
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_SET_CCA_THRESHOLD, aArgsLength);
++            break;
++
++        case MFG_CMD_GET_SET_CCA_THRESHOLD + 1: // set
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_GET_SET_CCA_THRESHOLD, aArgsLength, aArgs, -110, 0);
++            break;
++
++        case MFG_CMD_CONTINOUS_CCA_TEST:
++        {
++            if(aArgsLength == 3)
++            {
++                payload[1] = MFG_CMD_CONTINOUS_CCA_TEST;
++                payload[2] = MFG_CMD_ACTION_SET;
++                payload[4] = (uint8_t)atoi(aArgs[1]);
++                payload[5] = (uint8_t)atoi(aArgs[2]);
++                otPlatRadioMfgCommand(aContext, (uint8_t*)payload, payloadLen, &outputLen);
++                if((outputLen >= 4) && (payload[3] == 0))
++                {
++                    error = OT_ERROR_NONE;
++                }
++                else{
++                    error = OT_ERROR_FAILED;
++                }
++            }
++        }
++        break;
++
++        case MFG_CMD_GET_CCA_STATUS: // get
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_CCA_STATUS, aArgsLength);
++            break;
++
++        case MFG_CMD_CONTINOUS_ED_TEST:
++            error = ProcessMfgSetInt8(aContext, MFG_CMD_CONTINOUS_ED_TEST, aArgsLength, aArgs, -127, 127);
++            break;
++
++        case MFG_CMD_GET_ED_VALUE:
++            error = ProcessMfgGetInt8(aContext, MFG_CMD_GET_ED_VALUE, aArgsLength);
++            break;
++
++        default:
++            error = OT_ERROR_NOT_IMPLEMENTED;
++            break;
++        }
++    }
++
++    //HANDLE ERRORS
++    if(error == OT_ERROR_NONE)
++    {
++        syslog(LOG_INFO, "MFG command SUCCESS");
++    }
++    else if(aArgsLength == payloadLen)
++    {
++        // If user passed all the payload, this means this is a direct message for the RCP.
++        // Send it and print the return results.
++        for(idx = 0; idx < payloadLen; idx++)
++        {
++            payload[idx] = (uint8_t)atoi(aArgs[idx]);
++        }
++        otPlatRadioMfgCommand(aContext, (uint8_t *)payload, payloadLen, &outputLen);
++        for(idx = 0; idx < outputLen; idx++)
++        {
++            otCliOutputFormat("%d ", payload[idx]);
++        }
++        otCliOutputFormat("\r\n");
++        error = OT_ERROR_NONE;
++        syslog(LOG_INFO, "MFG command SUCCESS");
++    }
++    else if(error == OT_ERROR_INVALID_ARGS)
++    {
++        syslog(LOG_INFO, "MFG command Invalid parameter");
++        otCliOutputFormat("INVALID PARAMETER\r\n");
++    }
++    else if(error == OT_ERROR_NOT_IMPLEMENTED)
++    {
++        syslog(LOG_INFO, "MFG command not implemented");
++        otCliOutputFormat("NOT IMPLEMENTED\r\n");
++    }
++    else
++    {
++        syslog(LOG_INFO, "MFG command FAILED");
++        otCliOutputFormat("FAILED\r\n");
++    }
++}
++
+ static const otCliCommand kCommands[] = {
+ #if !OPENTHREAD_POSIX_CONFIG_DAEMON_ENABLE
+     {"exit", ProcessExit},
+@@ -469,6 +750,7 @@ static const otCliCommand kCommands[] = {
+     {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
+     {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
+     {"txpwrlimit", ProcessSetTxPowerLimit}, //=> Set TX power limit for 15.4
++    {"mfgcmd", ProcessMfgCommands} //=> Generic VSC for MFG RF commands
+ };
+ 
+ int main(int argc, char *argv[])
+diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
+index 9e2b6e11a..7f84d3ffc 100644
+--- a/src/posix/platform/radio.cpp
++++ b/src/posix/platform/radio.cpp
+@@ -690,3 +690,9 @@ otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit)
+     OT_UNUSED_VARIABLE(aInstance);
+     return sRadioSpinel.SetTxPowerLimit(txPowerLimit);
+ }
++
++otError otPlatRadioMfgCommand(otInstance *aInstance, uint8_t *payload, const uint8_t payloadLenIn, uint8_t *payloadLenOut)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    return sRadioSpinel.MfgCmd(payload, payloadLenIn, *payloadLenOut);
++}
+-- 
+
diff --git a/recipes-otbr/otbr/files/openthread_patches/0010-tcp-connection-war.patch b/recipes-otbr/otbr/files/openthread_patches/0010-tcp-connection-war.patch
new file mode 100644
index 0000000..6514c1f
--- /dev/null
+++ b/recipes-otbr/otbr/files/openthread_patches/0010-tcp-connection-war.patch
@@ -0,0 +1,40 @@
+diff --git a/src/posix/platform/netif.cpp b/src/posix/platform/netif.cpp
+index 572d59f7b..4dd35bdd0 100644
+--- a/src/posix/platform/netif.cpp
++++ b/src/posix/platform/netif.cpp
+@@ -150,6 +150,15 @@ extern int
+ #include "common/debug.hpp"
+ #include "net/ip6_address.hpp"
+ 
++// TCP reset packet header lenght is 20 bytes and packet header field reserves upper 6 bits
++#define TCP_RST_PKT_HDR_LEN_MASK    (0x14 << 2)
++#define TCP_RST_PKT_HDR_INDEX        52
++#define TCP_RST_PKT_FLAG_INDEX       53
++#define TCP_TH_RST                   0x04
++// Ipv6 reset packet header lenght is 60 bytes
++#define IPV6_RST_PKT_HDR_LEN      60
++#define IPV6_RST_PKT_HDR_INDEX    6
++
+ unsigned int gNetifIndex = 0;
+ char         gNetifName[IFNAMSIZ];
+ 
+@@ -966,8 +975,17 @@ static void processTransmit(otInstance *aInstance)
+ 
+     SuccessOrExit(error = otMessageAppend(message, &packet[offset], static_cast<uint16_t>(rval)));
+ 
+-    error   = otIp6Send(aInstance, message);
+-    message = nullptr;
++    if(!((rval == IPV6_RST_PKT_HDR_LEN) && (packet[IPV6_RST_PKT_HDR_INDEX] == OT_IP6_PROTO_TCP) &&
++        ((packet[TCP_RST_PKT_HDR_INDEX] & 0xFC) == TCP_RST_PKT_HDR_LEN_MASK) &&
++        (packet[TCP_RST_PKT_FLAG_INDEX] & TCP_TH_RST) == TCP_TH_RST))
++    {
++        error   = otIp6Send(aInstance, message);
++        message = nullptr;
++    }
++    else
++    {
++        error = OT_ERROR_DROP;
++    }
+ 
+ exit:
+     if (message != nullptr)
diff --git a/recipes-otbr/otbr/files/openthread_patches/0011-get-vsc-txpwr-limit.patch b/recipes-otbr/otbr/files/openthread_patches/0011-get-vsc-txpwr-limit.patch
new file mode 100644
index 0000000..abc071a
--- /dev/null
+++ b/recipes-otbr/otbr/files/openthread_patches/0011-get-vsc-txpwr-limit.patch
@@ -0,0 +1,142 @@
+diff --git a/include/openthread/platform/radio.h b/include/openthread/platform/radio.h
+index 83372e27e..a2c47efd4 100644
+--- a/include/openthread/platform/radio.h
++++ b/include/openthread/platform/radio.h
+@@ -1164,6 +1164,11 @@ otError otPlatRadioSetIeeeEui64(otInstance *aInstance, const otExtAddress *aIeee
+  *
+  */
+ otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit);
++/**
++ * @}
++ *
++ */
++otError otPlatRadioGetTxPowerLimit(otInstance *aInstance, uint8_t* txPowerLimit);
+
+ /**
+  * @}
+diff --git a/src/lib/spinel/radio_spinel.hpp b/src/lib/spinel/radio_spinel.hpp
+index cff161d99..b2110695a 100644
+--- a/src/lib/spinel/radio_spinel.hpp
++++ b/src/lib/spinel/radio_spinel.hpp
+@@ -198,6 +198,17 @@ public:
+      */
+     otError SetTxPowerLimit(uint8_t txPowerLimit);
+
++    /**
++     * @brief Get the Tx Power Limit for 15.4
++     *
++     * @param &txPowerLimit
++     * will contain the value set in IWx12
++     * (txPowerLimit = 0.5dBm step, TX power back off : 0.5dBm step )
++     *
++     * @return otError
++     */
++    otError GetTxPowerLimit(uint8_t &txPowerLimit);
++
+     /**
+      * @brief GetMfgChannel
+      * @param channel
+diff --git a/src/lib/spinel/radio_spinel_impl.hpp b/src/lib/spinel/radio_spinel_impl.hpp
+index 0668213fd..5c4b5a85c 100644
+--- a/src/lib/spinel/radio_spinel_impl.hpp
++++ b/src/lib/spinel/radio_spinel_impl.hpp
+@@ -1225,12 +1225,19 @@ template <typename InterfaceType, typename ProcessContextType>
+ otError RadioSpinel<InterfaceType, ProcessContextType>::SetTxPowerLimit(uint8_t txPowerLimit)
+ {
+     otError error;
+-    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, txPowerLimit));
++    SuccessOrExit(error = Set(SPINEL_PROP_VENDOR_NXP_GET_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, txPowerLimit));
+
+ exit:
+     return error;
+ }
+
++template <typename InterfaceType, typename ProcessContextType>
++otError RadioSpinel<InterfaceType, ProcessContextType>::GetTxPowerLimit(uint8_t &txPowerLimit)
++{
++    otError error = Get(SPINEL_PROP_VENDOR_NXP_GET_SET_TXPOWERLIMIT_CMD, SPINEL_DATATYPE_UINT8_S, &txPowerLimit);
++    return error;
++}
++
+ #define MAXBUFFERSIZE 16
+
+ template <typename InterfaceType, typename ProcessContextType>
+diff --git a/src/lib/spinel/spinel.h b/src/lib/spinel/spinel.h
+index cf1a4d56b..d31e109d3 100644
+--- a/src/lib/spinel/spinel.h
++++ b/src/lib/spinel/spinel.h
+@@ -4770,7 +4770,7 @@ enum
+     SPINEL_PROP_VENDOR_NXP_IR_CONFIG     = (SPINEL_PROP_VENDOR__BEGIN + 0x100),
+     SPINEL_PROP_VENDOR_NXP_IR_CMD        = (SPINEL_PROP_VENDOR__BEGIN + 0x101),
+     SPINEL_PROP_VENDOR_NXP_SET_EUI64_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10A),
+-    SPINEL_PROP_VENDOR_NXP_SET_TXPOWERLIMIT_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10B),
++    SPINEL_PROP_VENDOR_NXP_GET_SET_TXPOWERLIMIT_CMD = (SPINEL_PROP_VENDOR__BEGIN + 0x10B),
+     SPINEL_CMD_VENDOR_NXP_MFG  = (SPINEL_CMD_VENDOR__BEGIN + 0x3FF),
+
+     SPINEL_PROP_VENDOR__END   = 0x4000,
+diff --git a/src/posix/main.c b/src/posix/main.c
+index ed7cd99db..8120ced5d 100644
+--- a/src/posix/main.c
++++ b/src/posix/main.c
+@@ -458,13 +458,15 @@ static void ProcessSetEui64(void *aContext, uint8_t aArgsLength, char *aArgs[])
+     }
+ }
+
+-static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aArgs[])
++static void ProcessGetSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aArgs[])
+ {
++
++    uint8_t txPowerLimit = 0;
+     syslog(LOG_INFO, "SetTxPowerLimit");
+
+-    if( aArgsLength == 1 )
++    if( aArgsLength == 1 ) // set tx power limit
+     {
+-        uint8_t txPowerLimit = (uint8_t)atoi(aArgs[0]);
++        txPowerLimit = (uint8_t)atoi(aArgs[0]);
+         if((txPowerLimit>=1)&&(txPowerLimit<=44)){
+             syslog(LOG_INFO, "-> txPowerLimit : %d", txPowerLimit);
+         }else{
+@@ -473,6 +475,16 @@ static void ProcessSetTxPowerLimit(void *aContext, uint8_t aArgsLength, char *aA
+         otPlatRadioSetTxPowerLimit(aContext, txPowerLimit);
+         syslog(LOG_INFO, "SetTxPowerLimit DONE");
+     }
++    else if ( aArgsLength == 0 ) // get tx power limit
++    {
++        otPlatRadioGetTxPowerLimit(aContext, &txPowerLimit);
++
++        // Add value in syslog
++        syslog(LOG_INFO, "TX power Value value : %d", txPowerLimit);
++
++        // Print value as ot-cli output
++        otCliOutputFormat("%d\r\n", txPowerLimit);
++    }
+     else
+     {
+         syslog(LOG_INFO, "SetTxPowerLimit FAILED! Invalid input arg");
+@@ -749,7 +761,7 @@ static const otCliCommand kCommands[] = {
+     {"ircfg", ProcessIRConfig},    //=> OutOfBand Independent Reset Configuration ircfg <1> means OOB mode
+     {"ircmd", ProcessIRCmd},       //=> InBand Independent Reset command
+     {"seteui64", ProcessSetEui64}, //=> Set ieee.802.15.4 MAC Address
+-    {"txpwrlimit", ProcessSetTxPowerLimit}, //=> Set TX power limit for 15.4
++    {"txpwrlimit", ProcessGetSetTxPowerLimit}, //=> Set TX power limit for 15.4
+     {"mfgcmd", ProcessMfgCommands} //=> Generic VSC for MFG RF commands
+ };
+
+diff --git a/src/posix/platform/radio.cpp b/src/posix/platform/radio.cpp
+index 7f84d3ffc..ecc21e766 100644
+--- a/src/posix/platform/radio.cpp
++++ b/src/posix/platform/radio.cpp
+@@ -691,6 +691,12 @@ otError otPlatRadioSetTxPowerLimit(otInstance *aInstance, uint8_t txPowerLimit)
+     return sRadioSpinel.SetTxPowerLimit(txPowerLimit);
+ }
+
++otError otPlatRadioGetTxPowerLimit(otInstance *aInstance, uint8_t* txPowerLimit)
++{
++    OT_UNUSED_VARIABLE(aInstance);
++    return sRadioSpinel.GetTxPowerLimit(*txPowerLimit);
++}
++
+ otError otPlatRadioMfgCommand(otInstance *aInstance, uint8_t *payload, const uint8_t payloadLenIn, uint8_t *payloadLenOut)
+ {
+     OT_UNUSED_VARIABLE(aInstance);
diff --git a/recipes-otbr/otbr/otbr.bb b/recipes-otbr/otbr/otbr.bb
index d577bf7..561c0e1 100644
--- a/recipes-otbr/otbr/otbr.bb
+++ b/recipes-otbr/otbr/otbr.bb
@@ -1,4 +1,5 @@
 PN = "otbr"
+PR = "r0"
 SUMMARY = "OTBR on i.MX boards"
 DESCRIPTION = "OTBR applications"
 LICENSE = "BSD-3-Clause"
@@ -8,10 +9,9 @@ PATCHTOOL = "git"
 
 SRC_URI = "gitsm://github.com/openthread/ot-br-posix.git;branch=main"
 
-SRC_URI += "file://0001-correct-otbr-reference-scripts-install-folder.patch"
+SRC_URI += "file://0001-Update-otbr-agent-options-and-otbr-firewall-for-IW61.patch"
 SRC_URI += "file://0002-copy-prebuilt-frontend-files-instead-of-build.patch"
 SRC_URI += "file://0003-Install-pskc-for-otbr-agent-credentials-generation.patch"
-SRC_URI += "file://0004-Add-service-otbr_fwcfg-to-config-the-firewall-policy.patch"
 
 SRCREV = "1813352247aa60fb8993773918f1e5b4af6f3b79"
 
@@ -23,10 +23,45 @@ FILES:${PN} += "usr/lib"
 DEPENDS += " jsoncpp avahi boost pkgconfig-native mdns libnetfilter-queue ipset libnftnl nftables "
 RDEPENDS:${PN} += " jsoncpp mdns radvd libnetfilter-queue ipset libnftnl nftables bash "
 
+addtask do_openthread_repo_reset_and_patch after do_unpack before do_patch
+do_openthread_repo_reset_and_patch() {
+    SHA1_OPENTHREAD_FOR_OTBR="481a064f034496d93273f4b837d46559f7b74e5c"
+    SHA1_OTBR_COMMIT_FOR_5_15="528c152a35036ed0effe61e80cf25a978c458bfa"
+
+	#Bug for BSP 5.15 in OTBR repo, check if ${SHA1_OTBR_COMMIT_FOR_5_15} is present
+    cd ${S}
+    git show ${SHA1_OTBR_COMMIT_FOR_5_15}
+	res=$?
+	if [ ${res} -eq 1 ]; then
+		echo "Error: ${SHA1_OTBR_COMMIT_FOR_5_15} does not exist"
+	else
+		echo "OTBR patches: cherry-pick: solve compilation issue on BSP 5.15"
+		echo "----> cherry-pick to ${SHA1_OTBR_COMMIT_FOR_5_15}"
+		git cherry-pick ${SHA1_OTBR_COMMIT_FOR_5_15}
+	fi
+
+    cd ${S}/third_party/openthread/repo
+    echo "Applying on ${S}/third_party/openthread/repo:"
+    echo "-> git reset --hard ${SHA1_OPENTHREAD_FOR_OTBR}"
+    git reset --hard ${SHA1_OPENTHREAD_FOR_OTBR}
+    result=$?
+    if [ ${result} -ne 0 ]; then
+        echo "Cannot reset openthread to version '$SHA1_OPENTHREAD_FOR_OTBR', ABORT"
+        exit
+    fi
+
+    mkdir ${WORKDIR}/tmp_patches
+    cp $(dirname ${FILE})/files/openthread_patches/* ${WORKDIR}/tmp_patches
+    PATCHES_FILES_LIST=$(ls ${WORKDIR}/tmp_patches)
+	for i in ${PATCHES_FILES_LIST}; do
+		true | git apply ${WORKDIR}/tmp_patches/${i} --check
+		if [ $? == 0 ]; then
+			echo "----> Applying ${i}"
+			git apply ${WORKDIR}/tmp_patches/${i}
+		fi
+	done
+	rm -rf  ${WORKDIR}/tmp_patches
 
-do_configure:prepend () {
-    export REFERENCE_DEVICE=1
-    export OTBRWEB_PREBUILT_FRONTEND=1
 }
 
 def get_rcp_bus(d):
@@ -41,6 +76,54 @@ def get_rcp_bus(d):
     return ''
 
 inherit cmake
-EXTRA_OECMAKE = "-GNinja -DOTBR_BORDER_ROUTING=ON -DOTBR_WEB=ON -DBUILD_TESTING=OFF -DOTBR_DBUS=ON -DOTBR_SRP_ADVERTISING_PROXY=ON -DOT_THREAD_VERSION=1.3 -DOTBR_INFRA_IF_NAME=eth0 -DOT_LOG_LEVEL_DYNAMIC=OFF -DOT_FULL_LOGS=ON -DOT_JOINER=ON -DOT_LOG_LEVEL=DEBG -DOPENTHREAD_CONFIG_BACKBONE_ROUTER_DUA_NDPROXYING_ENABLE=1 -DOPENTHREAD_CONFIG_BACKBONE_ROUTER_MULTICAST_ROUTING_ENABLE=1 -DOT_FIREWALL=ON -DOT_DUA=ON -DOTBR_DUA_ROUTING=ON -DOT_DHCP6_SERVER=ON -DOT_DHCP6_CLIENT=ON -DOTBR_BACKBONE_ROUTER=ON -DOTBR_MDNS="mDNSResponder" -DOTBR_ENABLE_MDNS_MDNSSD=1 -DOTBR_TREL=ON -DOT_BACKBONE_ROUTER_MULTICAST_ROUTING=ON -DOT_COMMISSIONER=ON -DOT_COAP=ON -DOT_COAP_BLOCK=OFF -DOT_COAP_OBSERVE=ON -DOT_COAPS=ON -DOT_BORDER_ROUTER=ON -DOT_BORDER_AGENT=ON -DOTBR_BORDER_ROUTING_NAT64=ON -DOTBR_BORDER_AGENT=ON -DOT_DNS_CLIENT_SERVICE_DISCOVERY=ON -DOT_DNS_CLIENT=ON -DOT_ECDSA=ON -DOTBR_REST=ON -DOT_SRP_SERVER=ON -DOT_SRP_CLIENT=ON -DOTBR_DNSSD_DISCOVERY_PROXY=ON -DOT_REFERENCE_DEVICE=ON -DOT_DNSSD_SERVER=ON"
+EXTRA_OECMAKE = "-GNinja"
+EXTRA_OECMAKE += "-DOTBR_BORDER_ROUTING=ON"
+EXTRA_OECMAKE += "-DOTBR_WEB=OFF"
+EXTRA_OECMAKE += "-DBUILD_TESTING=OFF"
+EXTRA_OECMAKE += "-DOTBR_DBUS=ON"
+EXTRA_OECMAKE += "-DOTBR_SRP_ADVERTISING_PROXY=ON"
+EXTRA_OECMAKE += "-DOT_THREAD_VERSION=1.3"
+EXTRA_OECMAKE += "-DOTBR_INFRA_IF_NAME=mlan0"
+EXTRA_OECMAKE += "-DOT_LOG_LEVEL_DYNAMIC=OFF"
+EXTRA_OECMAKE += "-DOT_FULL_LOGS=ON"
+EXTRA_OECMAKE += "-DOT_JOINER=ON"
+EXTRA_OECMAKE += "-DOT_LOG_LEVEL=DEBG"
+EXTRA_OECMAKE += "-DOT_BACKBONE_ROUTER_DUA_NDPROXYING=ON"
+EXTRA_OECMAKE += "-DOT_BACKBONE_ROUTER_MULTICAST_ROUTING=ON"
+EXTRA_OECMAKE += "-DOT_FIREWALL=ON"
+EXTRA_OECMAKE += "-DOT_DUA=ON"
+EXTRA_OECMAKE += "-DOTBR_DUA_ROUTING=ON"
+EXTRA_OECMAKE += "-DOT_DHCP6_SERVER=ON"
+EXTRA_OECMAKE += "-DOT_DHCP6_CLIENT=ON"
+EXTRA_OECMAKE += "-DOTBR_BACKBONE_ROUTER=ON"
+EXTRA_OECMAKE += "-DOTBR_MDNS="mDNSResponder""
+EXTRA_OECMAKE += "-DOTBR_ENABLE_MDNS_MDNSSD=1"
+EXTRA_OECMAKE += "-DOTBR_TREL=ON"
+EXTRA_OECMAKE += "-DOT_BACKBONE_ROUTER_MULTICAST_ROUTING=ON"
+EXTRA_OECMAKE += "-DOT_COMMISSIONER=ON"
+EXTRA_OECMAKE += "-DOT_COAP=ON"
+EXTRA_OECMAKE += "-DOT_COAP_BLOCK=OFF"
+EXTRA_OECMAKE += "-DOT_COAP_OBSERVE=ON"
+EXTRA_OECMAKE += "-DOT_COAPS=ON"
+EXTRA_OECMAKE += "-DOT_BORDER_ROUTER=ON"
+EXTRA_OECMAKE += "-DOT_BORDER_AGENT=ON"
+EXTRA_OECMAKE += "-DOT_BORDER_ROUTING_NAT64=ON"
+EXTRA_OECMAKE += "-DOTBR_BORDER_AGENT=ON"
+EXTRA_OECMAKE += "-DOT_DNS_CLIENT=ON"
+EXTRA_OECMAKE += "-DOT_ECDSA=ON"
+EXTRA_OECMAKE += "-DOTBR_REST=ON"
+EXTRA_OECMAKE += "-DOT_SRP_SERVER=ON"
+EXTRA_OECMAKE += "-DOT_SRP_CLIENT=ON"
+EXTRA_OECMAKE += "-DOTBR_DNSSD_DISCOVERY_PROXY=ON"
+EXTRA_OECMAKE += "-DOT_REFERENCE_DEVICE=ON"
+EXTRA_OECMAKE += "-DOT_DNSSD_SERVER=ON"
 
 EXTRA_OECMAKE += "${@get_rcp_bus(d)}"
+
+do_install:append() {
+
+    mkdir ${D}${sysconfdir}/init.d
+    cp ${S}/script/otbr-firewall ${D}${sysconfdir}/init.d
+    chmod +x ${D}${sysconfdir}/init.d/otbr-firewall
+    cp ${S}/script/otbr-firewall_README.txt ${D}${sysconfdir}/init.d
+}
-- 
2.25.1

